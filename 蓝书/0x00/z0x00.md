---
title: 《算法竞赛进阶指南》0x00 基础算法
date: 2022-1-22
categories: 算法竞赛进阶指南
tag:
- 算法竞赛进阶指南
---

# 0x01 位运算

## 位运算基础概念

基本的位运算共 6 种，分别为按位与、按位或、按位异或、按位取反、左移和右移

|运算|运算符|解释|
|--|--|--|
|与|`&`|只有两个对应位都为 $1$ 时才为 $1$|
|或|`|`|只要两个对应位有一个 $1$ 时就为 $1$|
|异或|`^`|只有两个对应位不同时才为 $1$|
|取反|`~`|对二进制表示的每一位取反（有符号数的符号位也会取反）|
|左移|`<<`|对二进制表示向左移动 $1$ 位所得的值|
|右移|`>>`|对二进制表示向右移动 $1$ 位所得的值|

### 运算符优先级

|加减|移位|比较大小|位与|异或|位或|
|--|--|--|--|--|--|
|`+ -`|`<< >>`|`> < == !=`|`&`|`^`|`|`|

### 二进制常用操作

|操作|运算|
|--|--|
|取出整数 n 在二进制表示下的第 k 位|`(n >> k) & 1`|
|取出整数 n 在二进制表示下的第 0 ~ k-1 位 (后 k 位)|`n & ((1 << k) - 1)`|
|把整数 n 在二进制表示下的第 k 位取反|`n xor (1 << k)`|
|对整数 n 在二进制表示下的第 k 位赋值 1|`n | (1 << k)`|
|对整数 n 在二进制表示下的第 k 位赋值 0|`n & (~(1 << k))`|

## 位运算的应用

基本分类：

1. 高效地进行某些运算，代替其他低效的方式
2. 表示集合（常用于 **状态压缩DP**）
3. 题目本来就要求进行位运算

### 2 的幂次相关

#### 将一个数乘（除） 2 的非负整数次幂

向下取整，而非向零取整

```cpp
int mulPowerOfTwo(int n, int m) // 计算 n*(2^m)
{
  return n << m;
}
int divPowerOfTwo(int n, int m) // 计算 n/(2^m)
{
  return n >> m;
}
```

#### 判断一个数是不是 2 的非负整数次幂

二进制表示中只有一位 1

```cpp
bool isPowerOfTwo(int n)
{
    return n > 0 && (n & (n - 1)) == 0;
}
```

#### 对 2 的非负整数次幂取模 

保留那一位以内的所有二进制

```cpp
int modPowerOfTwo(int x, int mod)
{
    return x & (mod - 1);
}
```

### 模拟集合操作

|操作|集合表示|位运算语句|
|--|--|--|
|交集|$a \cap b$|`a & b`|
|并集|$a \cup b$|`a | b`|
|补集|$\overline{a}$|`~a`|
|差集|$a \setminus b$|`a & (~b)`|
对称差|$a \Delta b$|`a ^ b`|

#### 子集遍历

时间复杂度：$O(2^{popcount(u)})$

而遍历一个集合所有子集的子集，时间复杂度为 $O(3^n)$ （每个元素只有三中状态）

```cpp
// 遍历 u 的非空子集
for (int s = u; s; s = (s - 1) & u)
{
  // s 是 u 的一个非空子集
}
```

### 成对变换

1. $n$ 为奇数时，$n \oplus 1 = n - 1$
2. $n$ 为偶数时，$n \oplus 1 = n + 1$

因此，“0与1”、“2与3”、“4与5”、... 关于 $\oplus$ 是成对变换的

常用于 **图论** 中，**无向图** 用 **链式前向星** 存图时，找 **反向边**

### lowbit 运算

获得一个二进制表示数的最低位是 1 的位:

$$
\mathrm{lowbit}(x) = x \& -x = x \& (\sim x + 1)
$$

**lowbit运算** 可以找出整数二进制表示下的所有是 1 的位

**lowbit运算** 也是 **树状数组** 实现中的一个基本运算

```cpp
int lowbit(int u)
{
    return u & -u;
}
```

## 习题

### a^b

#### 题目描述

求 $a$ 的 $b$ 次方对 $p$ 取模的值。

**输入格式**

三个整数 $a$,$b$,$p$ ,在同一行用空格隔开。

**输出格式**

输出一个整数，表示 $a^b \bmod p$ 的值。

**数据范围**

$0≤a,b≤10^9$

$1≤p≤10^9$

**输入样例**：

```
3 2 7
```

**输出样例**：

```
2
```

#### 解析

快速幂模板

时间复杂度：$O(\log_2 b)$

```cpp
int power(int a, int b, int p)
{
    int res = 1 % p;
    for (; b; b >>= 1)
    {
        if (b & 1) res = (long long) res * a % p;
        a = (long long) a * a % p;
    }
    return res;
}
```

### 64位整数乘法

#### 题目描述

求 $a$ 乘 $b$ 对 $p$ 取模的值。

**输入格式**

第一行输入整数 $a$，第二行输入整数 $b$，第三行输入整数 $p$。

**输出格式**

输出一个整数，表示 $a * b \bmod p$ 的值。

**数据范围**

$1≤a,b,p≤10^{18}$

**输入样例**：

```
3
4
5
```

**输出样例**：
```
2
```

#### 解析一

龟速乘模板

时间复杂度：$O(\log_2 b)$

```cpp
long long mul(long long a, long long b, long long p)
{
    long long res = 0;
    for (; b; b >>= 1)
    {
        if (b & 1) res = (res + a) % p;
        a = a * 2 % p;
    }
    return res;
}
```

#### 解析二

公式：$a * b \bmod p = a * b - \lfloor{\dfrac{a * b}{p}}\rfloor * p$

时间复杂度：$O(1)$

虽然 $a * b$ 和 $\lfloor{\dfrac{a * b}{p}}\rfloor * p$ 都很大，但易知他们的差在 $0$ ~ $p-1$ 之间

因此，我们只需关注他们的低位即可

```cpp
long long mul(long long a, long long b, long long p)
{
    a %= p, b %= p;
    long long c = (long double) a * b / p;
    long long ans = a * b - c * p;
    return (ans % p + p) % p;
}
```

### 最短Hamilton路径

#### 题目描述

给定一张 $n$ 个点的带权无向图，点从 $0$ ∼ $n−1$ 标号，求起点 $0$ 到终点 $n−1$ 的最短 Hamilton 路径。

Hamilton 路径的定义是从 $0$ 到 $n−1$ 不重不漏地经过每个点恰好一次。

**输入格式**

第一行输入整数 $n$。

接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i$ 到 $j$ 的距离（记为 $a[i,j]$）。

对于任意的 $x$,$y$,$z$，数据保证 $a[x,x]=0$，$a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z]≥a[x,z]$。

**输出格式**

输出一个整数，表示最短 Hamilton 路径的长度。

**数据范围**

$1≤n≤20$，$0≤a[i,j]≤10^7$

**输入样例**：

```
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

**输出样例**：

```
18
```

#### 解析

```cpp
int f[1 << 20][20];
int hamilton(int n, int weight[20][20])
{
    memset(f, 0x3f, sizeof(f));
    f[1][0] = 0;
    for (int i = 1; i < 1 << n; i ++ )
        for (int j = 0; j < n; j ++ ) if (i >> j & 1)
            for (int k = 0; k < n; k ++ ) if (i >> k & 1)
                f[i][j] = min(f[i][j], f[i ^ 1 << j][k] + weight[k][j]);
    return f[(1 << n) - 1][n - 1];
}
```

### 起床困难综合症

#### 题目描述

21 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。

作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。

通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。

正是由于 drd 的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。

为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。

历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。

drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。

具体说来，drd 的防御战线由 n 扇防御门组成。

每扇防御门包括一个运算 $op$ 和一个参数 $t$，其中运算一定是 $OR,XOR,AND$ 中的一种，参数则一定为非负整数。

如果还未通过防御门时攻击力为 $x$，则其通过这扇防御门后攻击力将变为 $x op t$。

最终 drd 受到的伤害为对方初始攻击力 $x$ 依次经过所有 $n$ 扇防御门后转变得到的攻击力。

由于 atm 水平有限，他的初始攻击力只能为 $0$ 到 $m$ 之间的一个整数（即他的初始攻击力只能在 $0,1,…,m$ 中任选，但在通过防御门之后的攻击力不受 $m$ 的限制）。

为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。

**输入格式**

第 1 行包含 2 个整数，依次为 $n,m$，表示 drd 有 $n$ 扇防御门，atm 的初始攻击力为 $0$ 到 $m$ 之间的整数。

接下来 $n$ 行，依次表示每一扇防御门。每行包括一个字符串 $op$ 和一个非负整数 $t$，两者由一个空格隔开，且 $op$ 在前，$t$ 在后，$op$ 表示该防御门所对应的操作，$t$ 表示对应的参数。

**输出格式**

输出一个整数，表示 atm 的一次攻击最多使 drd 受到多少伤害。

**数据范围**

$2 \le n \le 10^5$，$2 \le m \le 10^9$，$0 \le t \le 10^9$

$op \in \{OR, XOR, AND\}$

**输入样例**：

```
3 10
AND 5
OR 6
XOR 7
```

**输出样例**：

```
1
```

**样例解释**

atm 可以选择的初始攻击力为 $0,1,…,10$。

假设初始攻击力为 $4$，最终攻击力经过了如下计算

```
4 AND 5 = 4

4 OR 6 = 6

6 XOR 7 = 1
```

类似的，我们可以计算出初始攻击力为 $1,3,5,7,9$ 时最终攻击力为 $0$，初始攻击力为 $0,2,4,6,8,10$ 时最终攻击力为 $1$，因此 atm 的一次攻击最多使 drd 受到的伤害值为 $1$。

#### 解析

```cpp
int n, m, one = (1 << 30) - 1, non = 0, res = 0;
cin >> n >> m;
for (int i = 1; i <= n; i++ )
{
    string op; int t; cin >> op >> t;
    if (op == "AND") one &= t, non &= t;
    else if (op == "XOR") one ^= t, non ^= t;
    else one |= t, non |= t;
}
for (int i = 30; i >= 0; i -- )
{
    if (non >> i & 1) res += 1 << i;
    else if (one >> i & 1 && m >= 1 << i)
    {
        m -= 1 << i;
        res += 1 << i;
    }
}
```

# 0x02 递推与递归


## 递推、递归与分治基础概念

一个实际问题的各种可能情况构成的 **集合** 称为 “**状态空间**”，**递推和递归** 就是程序遍历 **状态空间** 的两种基本方式。

我们把每个状态看作一个节点，根据递推和递归的法则：

1. 对于 **递归** 来说，每个 **状态节点** 都有 **唯一** 的 **父节点**（从父节点递归下来的），这些节点就会构成一棵 **树**
2. 对于 **递推** 来说，给个 **状态节点** 都有 **多个** **父节点**（视递推式而定），这些节点就会构成一个 **DAG**

从 **状态空间** 的角度来看，**递归和递推** 实际上就是对一个 **状态图/树** 的遍历，并求解 **问题边界** 的行为

如果我们把 **同类型** 的 **状态节点** 合并，以 **一个节点** 代表 **一类节点**，从而省掉重复的搜索分枝，那个行为就是我们常用的 **记忆化搜索** 算法

这也是我之前在某篇博客里提到过的，**动态规划** 作为具有 **递推性质** 的算法，本质上是在一个 **DAG** 上找 “**问题边界**” 的 **变换路线**

**递归** 算法中，程序在每个变换步骤中要执行的三个操作：

1. 缩小问题状态空间的规模
   程序尝试寻找“原问题”与“问题边界”之间的变换路线，并向正在探索的路线上迈出一步
2. 尝试求解规模缩小以后的问题，结果可能成功，也可能失败
3. 结果
   1. 如果成功，即找到了规模缩小后的问题的答案，那么将问题扩展到当前问题
   2. 如果失败，那么重新回到当前问题，程序可能会继续寻找当前问题的其他变换路线，直至最终确定当前问题无法求解

上述三个操作中有亮点颇为关键，一是 “**如何尝试求解规模缩小以后的问题**”。由于问题规模缩小为原问题的一个子问题，因此可以把它视为一个新的“原问题”，并由相同的程序进行求解，也就形成了“**自身调用自身**”的递归。二是求解子问题失败后，程序需要回到当前问题并去寻找其他的变换路线，因此把当前问题缩小为子问题时所做的对当前问题状态 **产生影响的事情应该全部失效**，这就是所谓的“**回溯时还原现场**”。

**分治法** 则是把一个问题划分为若干个规模更小的同类子问题，对这些子问题递归求解，然后在回溯时通过它们推导出原问题的解

## 常见的枚举形式和遍历方式

|枚举形式|状态空间规模|一般遍历方式|
|--|--|--|
|多项式|$n^k$，$k$ 为常数|循环(for)、递推|
|指数|$k^n$，$k$ 为常数|递归、位运算|
|排列|$n!$|递归、C++ next_permutation|
|组合|$C_n^m$|递归+剪枝|

## 习题

### 递归实现指数型枚举

#### 题目描述

从 $1∼n$ 这 $n$ 个整数中随机选取任意多个，输出所有可能的选择方案。

**输入格式**

输入一个整数 $n$。

**输出格式**

每行输出一种方案。

同一行内的数必须升序排列，相邻两个数用恰好 $1$ 个空格隔开。

对于没有选任何数的方案，输出空行。

本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。

**数据范围**

$1≤n≤15$

**输入样例**：

```
3
```

**输出样例**：

```
3
2
2 3
1
1 3
1 2
1 2 3
```

#### 解析

```cpp
vector<int> chosen;
void calc(int x)
{
    if (x == n + 1)
    {
        for (int i = 0; i < chosen.size(); i ++ )
            printf("%d ", chosen[i]);
        puts("");
        return;
    }
    calc(x + 1);
    chosen.push_back(x);
    calc(x + 1);
    chosen.pop_back();
}
int main()
{
    scanf("%d", &n);
    calc(1);
    return 0;
}
```

### 递归实现组合型枚举

#### 题目描述

从 $1∼n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。

**输入格式**

两个整数 $n,m$ ,在同一行用空格隔开。

**输出格式**

按照从小到大的顺序输出所有方案，每行 $1$ 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

**数据范围**

$n>0$ ,$0≤m≤n$ ,$n+(n−m)≤25$

**输入样例**：

```
5 3
```

**输出样例**：

```
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
```

#### 解析

```cpp
void calc(int u)
{
    if (chosen.size() > m || chosen.size() + (n - u + 1) < m) return;
    // 除了上面一步剪枝，剩余部分同上一题一摸一样
    ...
}
```

### 递归实现排列型枚举

#### 题目描述

把 $1∼n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。

**输入格式**

一个整数 $n$。

**输出格式**

按照从小到大的顺序输出所有方案，每行 $1$ 个。

首先，同一行相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。

**数据范围**

$1≤n≤9$

**输入样例**：

```
3
```

**输出样例**：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

#### 解析

```cpp
int order[20];
bool chosen[20];
void calc(int u)
{
    if (u == n + 1)
    {
        for (int i = 1; i <= n; i ++ )
            printf("%d ", order[i]);
        puts("");
        return;
    }
    for (int i = 1; i <= n; i ++ )
    {
        if (chosen[i]) continue;
        chosen[i] = true;
        order[u] = i;
        calc(u + 1);
        order[u] = 0;
        chosen[i] = false;
    }
}
```

### 费解的开关

#### 题目描述

你玩过“拉灯”游戏吗？

$25$ 盏灯排成一个 $5×5$ 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

下面这种状态

```
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。

**输入格式**

第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。

以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

**输出格式**

一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 $−1$。

**数据范围**

$0<n≤500$

**输入样例**：

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

**输出样例**：

```
3
2
-1
```

#### 解析

易发现三个简单性质：

1. 每个位置至多只会被点击一次
2. 若固定了第一行，则满足题意的点击方案至多只有 1 种
   当第 i 行某一位为 1 时，若前 i 行已被固定，只能点击第 i+1 行该位置上的数字才能使第 i 行的这一位变成 0
   从上到下使用归纳法可得上述结论
3. 点击的先后顺序不影响最终结果

根据上述性质而生的枚举策略：先确定第一行的状态，共 $2^5=32$ 种可能

然后根据第 i 行确定的状态，递推出第 i+1 行的方案

最后检查最后一行的状态是否合法，即可确定该方案是否合法

```cpp
int dx[5] = {0, -1, 0, 1, 0};
int dy[5] = {0, 0, 1, 0, -1};
char g[N][N], b[N][N];
void turn(int i, int j)
{
    for (int d = 0; d < 5; d ++ )
    {
        int x = i + dx[d], y = j + dy[d];
        if (x < 0 || x >= n || y < 0 || y >= n) continue;
        g[x][y] ^= 1;
    }
}
void solve()
{
    for (int i = 0; i < n; i ++ ) cin >> b[i];
    int res = -1;
    for (int op = 0, cnt; cnt = 0, op < 1 << n; op ++ )
    {
        memcpy(g, b, sizeof g);
        for (int i = 0; i < n; i ++ )
            if (op >> i & 1)
                turn(0, i), cnt ++ ;
        for (int i = 1; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                if (g[i - 1][j] == '0')
                    turn(i, j), cnt ++ ;
        if (cnt > 6) continue;
        bool flag = true;
        for (int i = 0; i < n; i ++ )
            if (g[n - 1][i] == '0')
                flag = false;
        if (flag && (res == -1 || res > cnt))
            res = cnt;
    }
    cout << res << endl;
}
```

### 奇怪的汉诺塔

#### 题目描述

汉诺塔问题，条件如下：

1. 这里有 A、B、C 和 D 四座塔。
2. 这里有 $n$ 个圆盘，$n$ 的数量是恒定的。
3. 每个圆盘的尺寸都不相同。
4. 所有的圆盘在开始时都堆叠在塔 A 上，且圆盘尺寸从塔顶到塔底逐渐增大。
5. 我们需要将所有的圆盘都从塔 A 转移到塔 D 上。
6. 每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。

请你求出将所有圆盘从塔 A 移动到塔 D，所需的最小移动次数是多少。

**输入格式**

没有输入

**输出格式**

对于每一个整数 $n$，输出一个满足条件的最小移动次数，每个结果占一行。

**数据范围**

$1≤n≤12$

#### 解析

易知 3 根柱子的情况下，汉诺塔的递推公式为：

$$
d[n] = 2 * d[n - 1] - 1
$$

即考虑最后一步：

1. 先把 $n-1$ 个盘子用 B、C 两柱 轮流操作，从 A柱 移到 B柱
2. 再把最下面最大的底盘从 A柱 移到 C柱
3. 最后将 B柱 剩余部分用A、C 两柱 轮流操作，从 B柱 移到 C柱

接着我们用 3柱 情况推导 4柱 情况

1. 先把 $i$ 个盘子用 B、C、D 三柱 轮流操作，从 A柱 移到 B柱
2. 再把 $n - i - 1$ 个盘子用 C、D 两柱 轮流操作，从 A柱 移到 C柱
3. 然后把最下面最大的底盘从 A柱 移到 D柱
4. 接着用 A、D 两柱 轮流操作，把 C柱 上 $n - i - 1$ 个盘子从 C柱 移到 D柱
5. 最后用 A、C、D 三柱 轮流操作，把 B柱 上 $i$ 个盘子从 B柱 移到 D柱

有递推式：

$$
f[n] = \min \{2 * (f[i] + d[n - i - 1]) + 1\} = 
\min \{2 * f[i] + d[n - i]\}
$$

根据上述推导，继续套循环递推，可以解时间允许条件下的任意 $n$ 柱 $m$ 盘的问题

```cpp
int f[15], d[15];
int main()
{
    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    for (int n = 1; n <= 12; n ++ )
    {
        d[n] = 2 * d[n - 1] + 1;
        for (int i = 0; i < n; i ++ )
            f[n] = min(f[n], 2 * f[i] + d[n - i]);
        cout << f[n] << endl;
    }
    return 0;
}
```

### 约数之和

#### 题目描述

假设现在有两个自然数 $A$ 和 $B$，$S$ 是 $A^B$ 的所有约数之和

请你求出 $S \bmod 9901$ 的值

**输入格式**

在一行中输入用空格隔开的两个整数 $A$ 和 $B$

**输出格式**

输出一个整数，代表 $S \bmod 9901$ 的值

**数据范围**

$0≤A,B≤5×10^7$

**输入样例**：

```
2 3
```

**输出样例**：

```
15
```

**注意**: $A$ 和 $B$ 不会同时为 $0$

#### 解析

考虑直接模拟，有 $A = p_1^{c_1} \cdot p_2^{c_2} \cdots p_n^{c_n}$，由此易得 $A^B = p_1^{Bc_1} \cdot p_2^{Bc_2} \cdots p_n^{Bc_n}$

由乘法分配律，易得 $A^B$ 的所有约数之和为：

$$
S = (1 + p_1 + \cdot + p_{1}^{Bc_1}) \cdot (1 + p_2 + \cdot + p_{2}^{Bc_2}) \cdots 
(1 + p_n + \cdot + p_{n}^{Bc_n})
$$

如果直接模拟这个过程，根据公式去求解 $S$，直接迭代求，显然复杂度会爆掉

易想到的一个优化是对每一个括号用等比数列求和公式，但是公式中有除法，在模运算下做等效除法需要求逆元

不过本题的模数 $9901$ 是质数，可以用 **费马小定理** 结合 **快速幂** 求逆元，否则就要用 **BSGS** 了

不妨换一种思路考虑本题，采用 **分治** 的思想来求解 $\mathrm{sum}(p, c) = 1 + p + \cdots + p^c$，不妨设 $c$ 为奇数，则

$$
\begin{aligned}
\mathrm{sum}(p, c + 1) &= \mathrm{sum}(p, c) + p^{c+1}
\\\\
\mathrm{sum}(p, c)
&= (1 + \cdots + p^{\frac{c-1}{2}}) +(p^{\frac{c+1}{2}} + \cdots + p^c)
\\\\
&= \mathrm{sum}(p, \frac{c-1}{2}) + p^{\frac{c+1}{2}} \cdot \mathrm{sum}(p, \frac{c-1}{2})
\\\\
&= \mathrm{sum}(p, \frac{c-1}{2}) \cdot (1 + p^{\frac{c+1}{2}})
\end{aligned}
$$

**状态空间** 的 **问题边界** 为 $\mathrm{sum}(p, 0) = 1$

利用该分治思想，求解本问题

```cpp
int calc(int p, int c)
{
    if (!c) return 1;
    if (c & 1) return (calc(p, c / 2) * (power(p, (c + 1) / 2) % mod + 1)) % mod;
    return (power(p, c) + calc(p, c - 1)) % mod;
}
```

### 分形之城

#### 题目描述

城市的规划在城市建设中是个大问题。

不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。

而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示：

![](https://www.acwing.com/media/article/image/2019/01/07/19_1ac25efe11-city.png)

当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。

对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。

虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 $N$，编号为 $A$ 和 $B$ 的两个街区的直线距离是多少。

街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 $10$ 米的正方形。

**输入格式**

第一行输入正整数 $n$，表示测试数据的数目。

以下 $n$ 行，输入 $n$ 组测试数据，每组一行。

每组数据包括三个整数 $N$,$A$,$B$，表示城市等级以及两个街区的编号，整数之间用空格隔开。

**输出格式**

一共输出 $n$ 行数据，每行对应一组测试数据的输出结果，结果四舍五入到整数。

**数据范围**

$1≤N≤31$, $1≤A,B≤2^{2N}$, $1≤n≤1000$

**输入样例**：

```
3 
1 1 2 
2 16 1 
3 4 33 
```

**输出样例**：

```
10 
30 
50 
```

#### 解析

显然，$n$ 级城市由四座 $n-1$ 级城市组成，其中左上的 $n-1$ 级城市顺时针旋转了90度再左右翻转，左下的 $n-1$ 级城市逆时针旋转了90度再左右翻转，其余两座 $n-1$ 级城市没有发生变化。

因此，在求解 $\mathrm{calc}(n, m)$ 时，因为 $n-1$ 级城市有 $2^{2n-2}$ 座房屋

所以可以先递归求解 $\mathrm{calc}(n-1, n \bmod 2^{2n-2})$，找出在 $n-1$ 级城市中，目标的位置

记为 $(x,y)$ 再根据 $m$ 推断出目标所在的 $n-1$ 级城市的编号，并根据该编号对 $(x,y)$ 进行坐标变换

四个编号的具体变换：(从0开始编号，$n-1$级城市边长为$2^{n-1}$)

1. 处于左上角的 $n-1$ 级城市
   1. 顺时针旋转90度，坐标变为：$(y, 2^{n-1} - x - 1)$
   2. 左右翻转，坐标变为：$(y, x)$
   3. 绝对位置上不用移动，坐标变为：$(y,x)$
2. 处于右上角的 $n-1$ 级城市
   1. 绝对位置上向右移一个 $n-1$ 级城市单位，坐标变为：$(x, y + 2^{n-1})$
3. 处于右下角的 $n-1$ 级城市
   1. 绝对位置上向右下移一个 $n-1$ 级城市单位，坐标变为：$(x + 2^{n-1}, y + 2^{n-1})$
4. 处于左下角的 $n-1$ 级城市
   1. 逆时针旋转90度，坐标变为：$(2^{n-1} - 1 - y, x)$
   2. 左右翻转，坐标变为：$(2^{n-1} - 1 - y, 2^{n-1} - 1 - x)$
   3. 绝对位置上向下移一个 $n-1$ 级城市单位，坐标变为：$(2^{n} - 1 - y, 2^{n-1} - 1 - x)$

```cpp
pair<long long, long long> calc(int n, long long m)
{
    if (!n) return {0, 0};
    long long len = 1ll << (n - 1), cnt = 1ll << (2 * n - 2);
    pair<long long, long long> pos = calc(n - 1, m % cnt);
    long long x = pos.x, y = pos.y;
    long long z = m / cnt;
    if (z == 0) return {y, x};
    if (z == 1) return {x, y + len};
    if (z == 2) return {x + len, y + len};
    if (z == 3) return {2 * len - 1 - y, len - 1 - x};
}
```

# 0x03 前缀和与差分


## 前缀和基础概念

对于一个给定的数列 $A$，它的前缀和数列 $S$ 是通过递推能求出的基本信息之一：

$$
S[i] = \sum_{j=1}^i A[j]
$$

**前缀和的作用**

一个部分和，即数列 $A$ 某个下标区间内的数的和，可表示为前缀和相减的形式

$$
\mathrm{sum}(l, r) = \sum_{i = l}^r A[i] = S[r] - S[l - 1]
$$

对于多维空间，同样可以定义前缀和，求部分和配合 **容斥原理** 即可实现

> 具体“容斥原理”会在数论章节讲解

例如 **二维前缀和**：

$$
\begin{aligned}
S[i, j] &= S[i - 1, j] + S[i, j - 1] - S[i - 1, j - 1] + A[i, j]
\\
\mathrm{sum}(x_1,y_1,x_2,y_2) &= S[x_2, y_2] - S[x_2, y_1 - 1] - S[x_1 - 1, y_2] + S[x_1 - 1, y_1 - 1]
\end{aligned}
$$

## 差分基础概念

对于一个给定的数列 $A$，它的差分数列 $B$ 定义为：

$$
B[1] = A[1], ~ B[i] = A[i] - A[i - 1] ~ (2 \le i \le n)
$$

**差分的作用**

“前缀和” 与 “差分” 互为逆运算：

1. 差分序列 $B$ 的前缀和序列就是原序列 $A$；
2. 前缀和序列 $S$ 的差分序列也是原序列 $A$；

把序列 $A$ 的区间 $[l,r]$ 加 $d$（即把 $A_{l},A_{l+1},\cdots,A_{r}$ 都加上 $d$），其差分序列 $B$ 的变化为：

$$
B[l] += d, ~ B[r + 1] -= d
$$

这有助于我们把原序列的 “区间操作” 转化为差分序列上的 “单点操作” 进行计算，从而降低求解难度

> 差分也可以在树上进行运用，会在图的章节进行讲解

## 习题

### 激光炸弹

#### 题目描述

地图上有 $N$ 个目标，用整数 $X_i,Y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $W_i$。

**注意**：不同目标可能在同一位置。

现在有一种新型的激光炸弹，可以摧毁一个包含 $R×R$ 个位置的正方形内的所有目标。

激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 $x$，$y$ 轴平行。

求一颗炸弹最多能炸掉地图上总价值为多少的目标。

**输入格式**

第一行输入正整数 $N$ 和 $R$，分别代表地图上的目标数目和正方形的边长，数据用空格隔开。

接下来 $N$ 行，每行输入一组数据，每组数据包括三个整数 $X_i$,$Y_i$,$W_i$，分别代表目标的 $x$ 坐标，$y$ 坐标和价值，数据用空格隔开。

**输出格式**

输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。

**数据范围**

$0≤R≤10^9$, $0<N≤10000$, $0≤X_i,Y_i≤5000$, $0≤W_i≤1000$

**输入样例**：

```
2 1
0 0 1
1 1 1
```

**输出样例**：

```
1
```

#### 解析

二维前缀和

值得注意的一点，虽然“目标”位于网格线的交点，而我们的前缀和是以方格为单位累加的

因此我们不妨把“目标”统一偏移到网格的方格中：$(x,y) \rightarrow (x + 0.5, y + 0.5)$

且偏移后，新问题与原问题等价，并且新边界变得更好处理

```cpp
for (int i = 1; i < N; i ++ )
    for (int j = 1; j < N; j ++ )
        s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
for (int i = m; i < N; i ++ )
    for (int j = m; j < N; j ++ )
        res = max(res, s[i][j] - s[i - m][j] - s[i][j - m] + s[i - m][j - m]);
```

### 增减序列

#### 题目描述

给定一个长度为 $n$ 的数列 $a_1,a_2,…,a_n$，每次可以选择一个区间 $[l,r]$，使下标在这个区间内的数都加一或者都减一。

求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。

**输入格式**

第一行输入正整数 $n$。

接下来 $n$ 行，每行输入一个整数，第 $i+1$ 行的整数代表 $a_i$。

**输出格式**

第一行输出最少操作次数。

第二行输出最终能得到多少种结果。

**数据范围**

$0<n≤10^5$, $0≤a_i<2147483648$

**输入样例**：

```
4
1
1
2
2
```

**输出样例**：

```
1
2
```

#### 解析

一维差分

区间修改，联想到用差分数组来维护，最终目标是使差分数组 **除首元素外全为 0**

每次修改一个区间，对于维护的差分数组变化情况分类：$(1 < l \le r < n)$

1. 修改 $[l, r]$ ：`b[l] -- , b[r + 1] ++ ` 或 `b[l] ++ , b[r + 1] -- `
2. 修改 $[1, r]$ ：`b[1] -- , b[r + 1] ++ ` 或 `b[1] ++ , b[r + 1] -- `
3. 修改 $[l, n]$ ：`b[l] -- ` 或 `b[l] ++ `
4. 修改 $[1, n]$ ：`b[1] --` 或 `b[1] ++ ` （多余操作）

观察易得:

1. 操作 4 是多余操作（不影响除首元素外元素值，相当于浪费一次操作，必然不是最优解）
2. 操作 2 和操作 3 一次只能改变 1 个元素的值，操作 1 一次可以改变 2 个元素的值
3. 操作 2 会改变首元素的值

为了让操作次数尽可能少，应尽可能使用操作 1

因此不妨设 $b_2,...,b_n$ 中正数总和为 $p$，$b_2,...,b_n$ 中负数总和为 $q$

然后让正负数配对，尽量执行操作 1，执行次数为 $min(p, q)$

剩余 $|p - q|$ 个要么全是正数，要么全是负数，调用操作 2 或操作 3 都可，执行次数为 $|p-q|$ 次

由于每次调用操作 2 时会改变一次首元素的值，因此首元素的可能值就有 $|p - q| + 1$ 种可能

因此最终答案为：$max(p, q)$ 和 $|p - q| + 1$

```cpp
long long p = 0, q = 0;
for (int i = 2; i <= n; i ++ )
{
    if (b[i] > 0) p += b[i];
    else if (b[i] < 0) q -= b[i];
}
cout << max(p, q) << endl << abs(p - q) + 1 << endl;
```

### 最高的牛

#### 题目描述

有 $N$ 头牛站成一行，被编队为 $1、2、3、…、N$，每头牛的身高都为整数。

当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。

现在，我们只知道其中最高的牛是第 $P$ 头，它的身高是 $H$ ，剩余牛的身高未知。

但是，我们还知道这群牛之中存在着 $M$ 对关系，每对关系都指明了某两头牛 $A$ 和 $B$ 可以相互看见。

求每头牛的身高的最大可能值是多少。

**输入格式**

第一行输入整数 $N,P,H,M$，数据用空格隔开。

接下来 $M$ 行，每行输出两个整数 $A$ 和 $B$ ，代表牛 $A$ 和牛 $B$ 可以相互看见，数据用空格隔开。

**输出格式**

一共输出 $N$ 行数据，每行输出一个整数。

第 $i$ 行输出的整数代表第 $i$ 头牛可能的最大身高。

**数据范围**

$1≤N≤10000$, $1≤H≤1000000$, $1≤A,B≤10000$, $0≤M≤10000$

**输入样例**：

```
9 3 5 5
1 3
5 3
4 3
3 7
9 8
```

**输出样例**：

```
5
4
5
3
4
4
5
5
5
```

**注意**： 此题中给出的关系对可能存在重复

#### 解析

我们希望每对牛之间可以相互看见，并且每头牛的高度最高

一开始不妨假设所有牛的高度都是给出的最高牛的高度

要使第 $A$ 头牛与第 $B$ 头牛可以互相看见，那么只需让区间 $[A + 1, B - 1]$ 的牛高度减少 1 即可

可以直接用差分序列来维护原序列，则每次修改操作为：`b[x + 1] -- , b[y] ++ `

```cpp
int b[N];
set<PII> S;
int main()
{
    cin >> n >> p >> h >> m; b[1] = h;
    while (m -- )
    {
        int x, y;
        cin >> x >> y;
        if (x > y) swap(x, y);
        if (S.count({x, y})) continue;
        S.insert({x, y});
        b[x + 1] -- , b[y] ++ ;
    }
    for (int i = 1; i <= n; i ++ )
    {
        b[i] = b[i - 1] + b[i];
        cout << b[i] << endl;
    }
    return 0;
}
```

# 0x04 二分


## 二分基础概念

**二分** 的基础用法是在 **单调序列** 或 **单调函数** 中进行查找。

因此当问题的答案具有 **单调性** 时，就可以通过 **二分把求解化为判定**。

有时在一些签到题上卡住的时候，不妨去想一想“二分”，这个简单的思想往往是最容易忽视的。

进一步地，还可以扩展到通过 **三分** 去解决 **单峰函数** 的 **极值** 以及相关问题。

> 不过大多情况下，在我们无法确定函数是 **单峰** 还是 **多峰** 时，优先推荐用 **爬山法** 来找极值

## 二分模板

### 整数域上二分

在单调递增序列 $a$ 中查找 $\ge x$  的数中最小的一个（即 $x$ 或 $x$ 的后继）：

```cpp
while (l < r)
{
    int mid = (l + r) >> 1;
    if (a[mid] >= x) r = mid; else l = mid + 1;
}
return a[l];
```

在单调递增序列 $a$ 中查找 $\le x$  的数中最大的一个（即 $x$ 或 $x$ 的前驱）：

```cpp
while (l < r)
{
    int mid = (l + r + 1) >> 1;
    if (a[mid] <= x) l = mid; else r = mid - 1;
}
return a[l];
```

> &emsp;&emsp;C++ STL 中的 `lower_bound` 与 `upper_bound` 函数实现了在一个序列中二分查找某个整数 $x$ 的后继，具体会在后面章节提及

### 实数域上二分

实数域上二分较为简单，确定好所需的精度 $eps$，一般需要保留 $k$ 位小数时，取 $eps = 10^{-(k+2)}$

```cpp
while (l + eps < r)
{
    double mid = (l + r) / 2;
    if (calc(mid)) r = mid; else l = mid;
}
```

有时精度不容易确定或表示时，可以用迭代固定次数的二分方法，通常情况下精度会比预设更高

```cpp
for (int i = 0; i < 100; i ++ )
{
    double mid = (l + r) / 2;
    if (calc(mid)) r = mid; else l = mid;
}
```

## 三分求单峰函数极值

有一类函数被称为 **单峰函数**（二次函数是特殊的单峰函数），它们有 **唯一的极值点**，且

1. （极大值点）在极值点左侧 **严格单调上升**，右侧 **严格单调下降**
2. （极小值点）在极值点左侧 **严格单调下降**，右侧 **严格单调上升**

以极大值点的单峰函数 $f$ 为例，在函数定义域 $[l, r]$ 上任取两个点 $lmid$ 和 $rmid$ 把函数分成三段

1. 若 $f(lmid) < f(rmid)$，则有两种情况

   1. $lmid$ 与 $rmid$ 同时处于极大值点左侧
   
   2. $lmid$ 处于极大值点左侧，$rmid$ 处于极大值点右侧
   
   但是无论是哪种情况，极大值点都在 $lmid$ 右侧，令 $l=lmid$

2. 若 $f(lmid) > f(rmid)$，则有两种情况

   1. $lmid$ 与 $rmid$ 同时处于极大值点右侧
   
   2. $lmid$ 处于极大值点左侧，$rmid$ 处于极大值点右侧
   
   但是无论是哪种情况，极大值点都在 $rmid$ 左侧，令 $r=rmid$

3. 若 $f(lmid) > f(rmid)$，任意令 $l = lmid$ 或 $r = rmid$ 其中之一即可

如果取 $lmid$ 和 $rmid$ 为三等分点，那么定义域范围每次缩小 $1 / 3$

如果取 $lmid$ 和 $rmid$ 为二等分点两侧及其接近的地方，那么定义域范围每次近似缩小 $1 / 2$

无论哪种，都可在 $\log$ 级别的时间复杂度内求出指定精度的极值

> &emsp;&emsp;函数极值点左右两侧要求必须是严格单调的，否则在取等时，无法判断极值点的位置，就只能用爬山法了

### 整数域上三分

有唯一极大值点的单峰函数（严格凸函数）

```cpp
while (l < r)
{
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    if (calc(lmid) >= calc(rmid)) r = rmid - 1; else l = lmid + 1;
}
return max(calc(l), calc(r));
```

有唯一极小值点的单峰函数（严格凹函数）

```cpp
while (l < r)
{
    int lmid = l + (r - l) / 3;
    int rmid = r - (r - l) / 3;
    if (calc(lmid) <= calc(rmid)) r = rmid - 1; else l = lmid + 1;
}
return min(calc(l), calc(r));
```

### 实数域上三分

```cpp
while (l + eps < r)
{
    double lmid = l + (r - l) / 3;
    double rmid = r - (r - l) / 3;
    if (calc(lmid) >= calc(rmid)) r = rmid; else l = lmid;
}
```

## 二分答案转化为判定

&emsp;&emsp;一个宏观的最优化问题可以抽象为函数，其“定义域”是该问题下的可行方案，对这些可行方案进行评估得到的数值构成函数的“值域”，最优解就是评估值最优的方案（不妨设评分越高越优）。

&emsp;&emsp;假设最优解的评分为 $S$，显然对于 $\forall x > S$，都不存在一个合法的方案达到 $x$ 分，否则与 $S$ 的最优性矛盾；而对于 $\forall x \le S$，一定存在一个合法的方案达到或超过 $x$ 分，因为最优解就满足这个条件。

&emsp;&emsp;这样问题的值域就具有一种特殊的单调性 —— 在 $S$ 的一侧合法、在 $S$ 的另一侧不合法，就像一个在 $(-\infty, S]$ 上值为 $1$，在 $(S,+\infty)$ 上值为 $0$ 的分段函数，可通过二分找到这个分界点 $S$。

&emsp;&emsp;通过二分，我们把求最优解问题，转化为给定一个值 $mid$，判定是否存在一个可行方案评分达到 $mid$ 的问题。

## 例题

### 分书问题

#### 题目描述

有 $N$ 本书排成一行，已知第 $i$ 本的厚度是 $A_i$

把它们分成连续的 $M$ 组，使 $T$ 最小化，其中 $T$ 表示厚度之和最大的一组的厚度

**输入格式**

第一行输入两个整数 $N, M$，数据用空格隔开

接下来 $N$ 行，每行输出一个正整数 $A_i$，表示第 $i$ 本书的厚度

**输出格式**

输出最小整数 $T$，其中 $T$ 表示厚度之和最大的一组的厚度

**数据范围**

$1 \le N, M \le 10^5$, $1 \le A_i \le 10^4$

**输入样例**：

```
3 2
1 2 3
```

**输出样例**：

```
3
```

#### 解析

“最大值最小” ，这是答案具有单调性，可用二分转化为判定的最常见、最典型的特征之一

如果我们以 “把书划分为 $M$ 组的方案” 作为定义域，“厚度之和最大的一组的厚度” 作为评分（值域）

需要最小化这个厚度，也就是评分越小越优

假设最终答案为 $S$，因为 $S$ 的最优性：

1. 如果要求每组厚度都 $< S$，那么这 $M$ 组一定不能容纳这些书，否则违背了 $S$ 的最优性
2. 如果要求每组厚度都 $> S$，那么一定存在一种分书方案使得组数不会超过 $M$

最优解就处于分书可行性的分界点上，利用二分转化为判定进行求解即可

```cpp
// 判定 n 本书分成 m 组，每组厚度之和 <= size，是否可行
bool valid(int size)
{
    int group = 1, rest = size;
    for (int i = 0; i < n; i ++ )
    {
        if (a[i] > size) return false;
        if (rest >= a[i]) rest -= a[i];
        else group ++ , rest = size - a[i];
    }
    return group <= m;
}
int main()
{
    //二分答案转化为判定
    int l = 0, r = accumulate(a, a + n, 0);
    while (l < r)
    {
        int mid = (l + r) / 2;
        if (valid(mid)) r = mid; else l = mid + 1;
    }
    cout << r << endl;
    return 0;
}
```

### 最佳牛围栏

#### 题目描述

农夫约翰的农场由 $N$ 块田地组成，每块地里都有一定数量的牛，其数量不会少于 $1$ 头，也不会超过 $2000$ 头。

约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。

围起区域内至少需要包含 $F$ 块地，其中 $F$ 会在输入中给出。

在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。

**输入格式**

第一行输入整数 $N$ 和 $F$，数据间用空格隔开。

接下来 $N$ 行，每行输入一个整数，第 $i+1$ 行输入的整数代表第 $i$ 片区域内包含的牛的数目。

**输出格式**

输出一个整数，表示平均值的最大值乘以 $1000$ 再 **向下取整** 之后得到的结果。

**数据范围**

$1≤N≤100000$, $1≤F≤N$

**输入样例**：

```
10 6
6 
4
2
10
3
8
5
9
4
1
```

**输出样例**：

```
6500
```

#### 解析

题目转译：给定正整数序列 $A$，求一个平均数最大的，长度不小于 $F$ 的子段

二分答案，判定“是否存在一个长度不小于 $F$ 的子段，平均数不小于二分的值”

再把数列中每个数减去二分值，问题就转化为判定“是否存在一个长度不小于 $F$ 的子段，子段和非负”

考虑一个子问题如何求解：求一个数列的最大子段和

最大子段和是一个经典模型，可以在线性的时间内完成求解，方法是不断把新的数加入当前子段，如果当前子段和变成了负数，就清空整个子段。扫描过程中出现的最大子段和即位所求。这里用到了动态规划的思想。

那么如何求一个长度不小于 $F$ 的最大子段和呢？

将子段和转化为前缀和相减的形式，有：

$$
\begin{aligned}
\max_{i - j \ge F} \{ A_{j+1} + A_{j+2} + \cdots + A_i \}
&=
\max_{i - j \ge F} \{ sum_i - sum_j \}
\\
&=
\max_{F \le i \le n} \{ sum_i -  \min_{0 \le j \le i - F}\{ sum_j \} \}
\end{aligned}
$$

这与上面直接求最大子段和有着异曲同工之妙，最大子段和维护的是 $\max\limits_{1 \le i \le n} \{ sum_i -  \min\limits_{0 \le j \lt i}\{ sum_j \} \}$

如果直接用前缀和来做，最大子段和维护的就是 $0 \le j \lt i$ 前缀最小值

带长度不小于 $F$ 限制的最大子段和维护的就是 $0 \le j \le i - F$ 前缀最小值

于是可以写出判定函数 `valid` 了：

```cpp
bool valid(double avg)
{
    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i] - avg;
    double min_val = 0;
    for (int i = m; i <= n; i ++ )
    {
        min_val = min(min_val, s[i - m]);
        if (s[i] > min_val) return true;
    }
    return false;
}
```

### 特殊排序

#### 题目描述

有 $N$ 个元素，编号 $1,2..N$，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。

注意：不存在两个元素大小相等的情况。

也就是说，元素的大小关系是 $N$ 个点与 $\dfrac{N×(N−1)}{2}$ 条有向边构成的任意有向图。

然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 $10000$ 次提问来获取信息，每次提问只能了解某两个元素之间的关系。

现在请你把这 $N$ 个元素排成一行，使得每个元素都小于右边与它相邻的元素。

你可以通过我们预设的 $bool$ 函数 $compare$ 来获得两个元素之间的大小关系。

例如，编号为 $a$ 和 $b$ 的两个元素，如果元素 $a$ 小于元素 $b$，则 `compare(a,b)` 返回 `true`，否则返回 `false`。

将 $N$ 个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。

**数据范围**

$1≤N≤1000$

**输入样例**

```
[[0, 1, 0], [0, 0, 0], [1, 1, 0]]
```

**输出样例**

```
[3, 1, 2]
```

#### 解析

这里用二分法可能有点难以理解，不过给出数学证明就容易理解多了

由于题目中说明，元素之间的关系不具有传递性，因此会让我们觉得失去了单调的性质，就不能二分

不过还是可以证明二分的做法是正确的，假设前 $k - 1$ 个元素已经有序排好，现插入第 $k$ 个元素：

情况一：第 $k$ 个元素 < 第 $mid$ 个元素

则第 $k$ 个元素一定能在区间 $[l - 1, mid]$ 之间找到插入位置，用数学归纳法证明：

若第 $k$ 个元素 **大于** 第 $mid - 1$ 个元素，则第 $k$ 个元素可以插在第 $mid-1$ 个元素 **后面**

若第 $k$ 个元素 **大于** 第 $mid - 2$ 个元素，则第 $k$ 个元素可以插在第 $mid-2$ 个元素 **后面**

......

若第 $k$ 个元素 **大于** 第 $1$ 个元素，则第 $k$ 个元素可以插在第 $1$ 个元素 **后面**

若第 $k$ 个元素 **小于** 第 $1$ 个元素，则第 $k$ 个元素可以插在第 $1$ 个元素 **前面**

情况二：第 $k$ 个元素 > 第 $mid$ 个元素

则第 $k$ 个元素一定能在区间 $[mid, r + 1]$ 之间找到插入位置，用数学归纳法同理易证

这样每次将查找区间缩小一倍，根据基于比较的排序的下界，可以在 $n\log n$ 的时间内完成排序

```cpp
class Solution {
public:
    vector<int> specialSort(int N) {
        vector<int> res;
        for (int i = 1; i <= N; i ++ )
        {
            int l = 0, r = res.size();
            while (l < r)
            {
                int mid = (l + r) >> 1;
                if (compare(i, res[mid])) r = mid; else l = mid + 1;
            }
            res.push_back(i);
            for (int j = res.size() - 1; j > l; j -- ) swap(res[j - 1], res[j]);
        }
        return res;
    }
};
```

# 0x05 排序


## 排序基本概念

程序设计中，常用排序共分为三类：

1. 选择排序、插入排序、冒泡排序
2. 堆排序、归并排序、快速排序
3. 计数排序、基数排序、桶排序

前两类是 **基于比较的排序算法**

对 $n$ 的元素排序时，若元素比较大小的时间复杂度为 $O(1)$，则

1. 第一类排序算法的时间复杂度为 $O(n^2)$
2. 第二类排序算法的时间复杂度为 $O(n\log n)$

**基于比较的排序算法** 的时间复杂度下界为 $O(n\log n)$

第三类算法不是直接比较大小，而是对被排序的数值采取按位划分、分类映射等处理方式

其时间复杂度不仅与 $n$ 有关，还与数值的大小范围 $m$ 有关

## 离散化

排序算法的第一个应用时离散化

离散化就是把无穷大集合中的若干个元素映射为有限集合以便于统计的方法

在很多情况下，问题的范围虽然定义在整数集合 $\mathbb{Z}$，但是只涉及其中 $m$ 个有限数值，并且与数值的绝对大小无关（只把这些数值作为代表，或只与它们的相对顺序有关）

此时，我们就可以把整数集合 $\mathbb{Z}$ 中的这 $m$ 个整数与 $1 \sim m$ 建立映射关系

如果有一个时间、空间复杂度与数值范围 $\mathbb{Z}$ 大小有关，在离散化后，该算法的时间、空间复杂度就降低为与 $m$ 有关

并且离散化以后，我们仍然保持原数据映射到新数据后相对大小不变

```cpp
vector<int> xs;
void discrete(vector<int> &a)
{
    sort(a.begin(), a.end());
    a.erase(unique(a.begin(), a.end()), a.end());
}
int query(int x)
{
    return lower_bound(a.begin(), a.end(), x) - a.begin();
}
```

## 第k个数

如何求解一个长度为 $n$ 的序列的第 $k$ 个数

一个较为简单的做法是直接排序，然后输出从小到大的第 $k$ 个数，时间复杂度为 $O(n \log n)$

实际上利用快速排序的思想，可以在 $O(n)$ 的时间即可求出第 $k$ 个数

快排思想是：每一层递归中，随机选取一个数为基准，把比他小的交换到左边，比他大的交换到右边

然后递归左右两边继续处理，平均情况下的时间复杂度为 $O(n \log n)$

实际上，每次选取基准值以后，可以统计出小于基准值的数的数量 $cnt$

如果 $k \le cnt$，就去左边寻找第 $k$ 小数；否则，去右边寻找第 $k - cnt$ 大数

这样递归求解，平均意义下的时间复杂度为 $O(n + \frac{n}{2} + \frac{n}{4} + \cdots + 1) = O(2n) = O(n)$

```cpp
int calc(int l, int r, int k)
{
    if (l >= r) return a[l];
    int i = l - 1, j = r + 1, pivot = a[l + r >> 1];
    while (i < j)
    {
        do ++ i; while (a[i] < pivot);
        do -- j; while (a[j] > pivot);
        if (i < j) swap(a[i], a[j]);
    }
    if (j - l + 1 >= k) return calc(l, j, k);
    return calc(j + 1, r, k - (j - l + 1));
}
```

> 若要求解第 k 大数，直接调用 `calc(l, r, n - k)` 找第 $n-k$ 小数即可

## 逆序对

对于一个序列 $a$，若 $i < j$ 且 $a_i > a_j$，则称 $a_i$ 与 $a_j$ 构成逆序对

使用归并排序可以在 $O(n\log n)$ 的时间里求出一个长度为 $n$ 的序列中逆序对个数

归并排序递归处理好左 $[l, mid]$ 右 $[mid + 1, r]$ 两边序列后，进行合并时，可以求解 $(a_i,a_j)$ 的逆序对个数，其中 $i \in [l, mid]$，$j \in [mid + 1, r]$

由数学归纳法，读者自证不难，每次合并两个序列，可以求出整个序列中全部的逆序对数量

```cpp
long long cal_revpair(int a[], int l, int r)
{
    if (l >= r) return 0;
    
    int mid = (l + r) >> 1;
    long long cnt = cal_revpair(a, l, mid) + cal_revpair(a, mid + 1, r);
    
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r)
    {
        if (a[i] > a[j]) cnt += mid - i + 1, b[k ++ ] = a[j ++ ];
        else b[k ++ ] = a[i ++ ];
    }
    while (i <= mid) b[k ++ ] = a[i ++ ];
    while (j <= r) b[k ++ ] = a[j ++ ];
    
    for (int i = 0; i < k; i ++ ) a[l + i] = b[i];
    return cnt;
}
```

> 求逆序对还可以用树状数组，稍微有点复杂，必要的时候还要先离散化再用树状数组，之后会提及

## 中位数

有序序列中，中位数具有一些很优美的性质，可以引出一系列与它相关的问题

动态维护序列的中位数也非常值得探讨，在后续例题中会进行具体讲解

## 习题

### 电影

#### 题目描述

莫斯科正在举办一个大型国际会议，有 $n$ 个来自不同国家的科学家参会。

每个科学家都只懂得一种语言。

为了方便起见，我们把世界上的所有语言用 $1$ 到 $10^9$ 之间的整数编号。

在会议结束后，所有的科学家决定一起去看场电影放松一下。

他们去的电影院里一共有 $m$ 部电影正在上映，每部电影的语音和字幕都采用不同的语言。

对于观影的科学家来说，如果能听懂电影的语音，他就会很开心；如果能看懂字幕，他就会比较开心；如果全都不懂，他就会不开心。

现在科学家们决定大家看同一场电影。

请你帮忙选择一部电影，可以让观影很开心的人最多。

如果有多部电影满足条件，则在这些电影中挑选观影比较开心的人最多的那一部。

**输入格式**

第一行输入一个整数 $n$，代表科学家的数量。

第二行输入 $n$ 个整数 $a_1,a_2,…,a_n$，其中 $a_i$ 表示第 $i$ 个科学家懂得的语言的编号。

第三行输入一个整数 $m$，代表电影的数量。

第四行输入 $m$ 个整数 $b_1,b_2,…,b_m$，其中 $b_i$ 表示第 $i$ 部电影的语音采用的语言的编号。

第五行输入 $m$ 个整数 $c_1,c_2,…,c_m$，其中 $c_i$ 表示第 $i$ 部电影的字幕采用的语言的编号。

请注意对于同一部电影来说，$bi≠ci$。

同一行内数字用空格隔开。

**输出格式**

输出一个整数，代表最终选择的电影的编号。电影编号 $1∼m$。

如果答案不唯一，输出任意一个均可。

**数据范围**

$1≤n,m≤2 \times 10^5$, $1≤ai,bi,ci≤10^9$

**输入样例**：

```
3
2 3 2
2
3 2
2 3
```

**输出样例**：

```
2
```

#### 解析

虽然语言范围在 int 以内，但是这 $m$ 部电影与 $n$ 个人最多涉及 $2m + n$ 种语言

不妨将所有有效语言离散化处理，用 $0 \sim 2m+n-1$ 之间的整数代替每种语言

接着用一个数组直接统计会每种语言的人的数量，从而选择满足题意的电影

时间复杂度：$O((n+m)\log(n+m))$

```cpp
discrete();
for (int i = 1; i <= n;i ++ )
{
    int x = query(a[i]);
    cnt[x] ++ ;
}
int s1 = 0, s2 = 0, res = 1;
for (int i = 1; i <= m; i ++ )
{
    int x1 = query(b[i]), x2 = query(c[i]);
    if (cnt[x1] > s1) s1 = cnt[x1], s2 = cnt[x2], res = i;
    else if (cnt[x1] == s1 && cnt[x2] > s2) s2 = cnt[x2], res = i;
}
cout << res << endl;
```

### 货仓选址

#### 题目描述

在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1∼A_N$

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小

**输入格式**

第一行输入整数 $N$

第二行 $N$ 个整数 $A_1∼A_N$

**输出格式**

输出一个整数，表示距离之和的最小值。

**数据范围**

$1≤N≤10^5$, $0≤A_i≤4\times 10^4$

**输入样例**：

```
4
6 2 9 1
```

**输出样例**：

```
12
```

#### 解析

这里给出蓝书上的证明

将 $A_1 \sim A_n$ 排序，设货仓建在 $X$ 处，$X$ 处左侧的商店有 $P$ 家，$X$ 处右侧的商店有 $Q$ 家

1. 若 $P < Q$，则每把货仓的选址向右移动 $1$ 单位距离，距离之和就会变小 $Q - P$
2. 若 $P > Q$，则每把货仓的选址向左移动 $1$ 单位距离，距离之和就会变小 $P - Q$

然后再分奇偶讨论：

1. 当 $N$ 为奇数时，显然建在 $A[(N + 1) / 2]$ 处最优，此时 $P = Q$

2. 当 $N$ 为偶数时，建在 $\big[A[N / 2], A[N / 2 + 1] \big]$ 之间的任何位置都是最优

对于第二种情况，不妨建在 $A[N / 2]$ 处，这样无论奇偶都可以统一处理成 $A[(N + 1) / 2]$ 了

对于下标从 $0$ 开始，就是 $A[N / 2]$

```cpp
sort(a, a + n);
int s = 0;
for (int i = 0; i < n; i ++ ) s += abs(a[n / 2] - a[i]);
cout << s << endl;
```

### 七夕祭

#### 题目描述

七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。

于是 TYVJ 今年举办了一次线下七夕祭。

Vani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。

TYVJ 七夕祭和 11 区的夏祭的形式很像。

矩形的祭典会场由 $N$ 排 $M$ 列共计 $N×M$ 个摊点组成。

虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。

Vani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。

不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。

两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。

由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。

现在 Vani 想知道他的两个要求最多能满足多少个。

在此前提下，至少需要交换多少次摊点。

**输入格式**

第一行包含三个整数 $N$ 和 $M$ 和 $T$，$T$ 表示 cl 对多少个摊点感兴趣。

接下来 $T$ 行，每行两个整数 $x,y$，表示 cl 对处在第 $x$ 行第 $y$ 列的摊点感兴趣。

**输出格式**

首先输出一个字符串。

如果能满足 Vani 的全部两个要求，输出 `both`；

如果通过调整只能使得各行中 cl 感兴趣的摊点数一样多，输出 `row`；

如果只能使各列中 cl 感兴趣的摊点数一样多，输出 `column`；

如果均不能满足，输出 `impossible`。

如果输出的字符串不是 `impossible`， 接下来输出最小交换次数，与字符串之间用一个空格隔开。

**数据范围**

$1≤N,M≤100000$, $0≤T≤min(N∗M,100000)$, $1≤x≤N$, $1≤y≤M$

**输入样例**：

```
2 3 4
1 3
2 1
2 2
2 3
```

**输出样例**：

```
row 1
```

#### 解析

观察易得：

1. 只做列相邻交换时，不会改变每行的兴趣摊点数；
2. 只做行相邻交换时，不会改变每列的兴趣摊点数；

那不妨把原问题拆分成两个相似的子问题，先后计算列相邻交换和行相邻交换的最小次数，从而求解原问题

思考如何只做列相邻交换，使得每列的兴趣摊点数相等

由于我们只关心每列中，兴趣摊点总数，因此不妨把每列压缩成一个点，兴趣摊点总数表示该点的值

于是该模型就变成，在一个环形图上，每次只能相邻传递一件物品，求传递最小次数使得每个点的物品数相同

这就是经典的：“**环形纸牌均分问题**”，推导方式有两种，我先给出 **蓝书上的推导**：

**考虑 “纸牌均分问题” 如何解决？**

设一共有 $M$ 个人，每个人初始的纸牌数量为 $c_i$，纸牌总数为 $T$

显然当 $M \nmid T$  时，方案不存在，现只考虑方案存在的情况

第 1 个人为了达到平均持有数，需要向第 2 个人传递 $c_1 - T / M$ 数量的牌（正数是给，负数是拿）

第 2 个人为了达到平均持有数，需要向第 3 个人传递 $c_2 - T / M + c_1 - T / M$ 数量的牌

......

第 n-1 个人为了达到平均持有数，需要向第 n 个人传递 $\sum_{i=1}^{n-1} c_i - (n-1) \times T / M$ 数量的牌

此时前 n-1 人都达到了平均数，则第 n 个人必然也达到了平均数

统计易得，最小交换次数为：

$$
\sum_{i=1}^{n-1} \Big| { \sum_{j = 1}^i (c_j - \frac{T}{M}) } \Big|
$$

不妨设 $A_i = c_i - T / M$，于是化简可得：

$$
\sum_{i=1}^{n-1} \Big| { \sum_{j=1}^i A_j } \Big| = 
\sum_{i=1}^{n-1} | { S_i } | \quad\text{其中 } S_i \text{ 为 } A_i \text{ 的前缀和，即 } S_i = \sum_{j=1}^i A_j
$$

**考虑 “纸牌均分问题” 如何延伸到 “环形纸牌均分问题” ？**

环形区间的问题，第一想到的就是 **破环成链** 了

经过思考发现，一定存在一个最优解方案，环上有相邻的两个人之间没有发生交换

> 这部分证明如下：  
> 如果环上相邻两人全部发生交换，则会出现两种情形：（正数传递为有向边的正向方向）  
> 1. 出现一个环 
>    这种方案肯定不是最优解，因为给出去的纸牌经过一圈收回来了，显然浪费了操作次数   
>    我们在这个环上断开交易数量最小的一条交换边，并使其他边减少该边的交换数量，必然不会使方案变差   
> 2. 出现一个点到达另一个点有两条路径  
>    我们可以断开起点两条出边中 $val = cnt \times w$ 最小的那一套边，并该边权值累加到另一条路径的每一条边上，其结果不会变差（其中 $cnt$ 是起点到终点路径上经过的点数，$w$ 是这条边的权重）

一个朴素的做法是直接枚举断点的位置，然后做一遍线性纸牌均分，但是时间复杂度为 $O(n^2)$ 不可取，需要推导

现将这 $n$ 个人的 $A_i$ 和 $S_i$ 罗列出来 $(A_i = \sum\limits_{j=1}^n (c_j - \dfrac{T}{M}), S_i = \sum\limits_{j = 1}^i A_j)$

$$
\begin{matrix}
A_1 & S_1 \\
A_2 & S_2 \\
\cdots & \cdots \\
A_k & S_k \\
A_{k+1} & S_{k+1} \\
\cdots & \cdots \\
A_n & S_n
\end{matrix}
$$

考虑在第 $k$ 个人之后断开，则环化成链有：

$$
\begin{matrix}
A_{k+1} & S_{k+1} - S_k \\
\cdots & \cdots \\
A_n & S_n - S_k \\
A_1 & S_1 + S_n - S_k \\
A_2 & S_2 + S_n - S_k \\
\cdots & \cdots \\
A_k & S_k + S_n - S_k \\
\end{matrix}
$$ 

又易知 $S_n = \sum c_j - n \times T / m = 0$，故求得最小步数为：

$$
\sum_{i=1}^n |S_i - S_k| \quad\text{其中 } S_i \text{ 为 } A_i \text{ 的前缀和，即 } S_i = \sum_{j=1}^i A_j
$$

该绝对值不等式最小值的求解，就同上一题 “货仓选址” 异曲同工了

因此 $S_k$ 的选择，就取 $S_i$ 排序后的中位数即可

**第二种推导方式**

这种推导方式相较于上一种，思维量小，但对公式的变形要求高，是直接统计每个点

考虑直接在环上求解，环的顺时针方向设为正方向，若边权为正，表示左向右传递；反之则是右向左传递

设 $d_i$ 表示第 $i$ 个人向第 $(i+1)\bmod n$ 传递的所有纸牌数量

传递完成后的结束是所有人的纸牌数量变成平均数，以此建立方程组有：

$$
\begin{cases}
avg =& c_1 - d_1 + d_n \\
avg =& c_2 - d_2 + d_1 \\
\cdots \\
avg =& c_{n-1} - d_{n-1} + d_{n-2} \\
avg =& c_{n} - d_{n} + d_{n-1}
\end{cases}
\qquad \Rightarrow \qquad
\begin{cases}
d_1 &= c_1 - avg + d_n \\
d_2 &= c_2 - avg + d_1 \\
\cdots \\
d_{n-1} &= c_{n-1} - avg + d_{n-2} \\
d_n &= c_{n} - avg + d_{n-1}
\end{cases}
$$

观察易得，相邻两个等式之间，有可以代入的项，从上到下用滚动相消法可得：

$$
\begin{cases}
d_1 =& c_1 - avg + d_n \\
d_2 =& \sum\limits_{i=1}^2 c_i - 2 \times avg + d_n \\
\cdots \\
d_{n-1} =& \sum\limits_{i=1}^{n-1} c_i - (n-1) \times avg + d_n \\
d_n =& \sum\limits_{i=1}^{n} c_i - n \times avg + d_n
\end{cases}
$$

易得通项：$d_i = \sum\limits_{j=1}^{i} c_j - i \times avg + d_n = d_n + \sum\limits_{j=1}^{i} (c_j - avg) = d_n - \sum\limits_{j=1}^{i} (avg - c_j)$

不妨设 $A_i = avg - c_i, S_i = \sum\limits_{j = 1}^i A_j$，则通项可以化简为：$d_i = d_n - \sum\limits_{j=1}^{i}A_j$

则总共的操作数为：

$$
\sum_{i=1}^n d_i = \sum_{i=1}^n |d_n - \sum_{j=1}^i A_j| = 
\sum_{i=1}^n |d_n - S_i|
$$

由 **绝对值不等式** 易得：$d_n$ 应取 $S_i$ 排序后的中位数

```cpp
long long calc(int c[], int n)
{
    int avg = t / n;
    for (int i = 1; i <= n; i ++ ) a[i] = c[i] - avg;
    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i];
    sort(s + 1, s + n + 1);
    long long res = 0;
    for (int i = 1; i <= n; i ++ ) res += abs(s[i] - s[(n + 1) / 2]);
    return res;
}
```

### 动态中位数

#### 题目描述

依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。

**输入格式**

第一行输入一个整数 $P$，代表后面数据集的个数，接下来若干行输入各个数据集。

每个数据集的第一行首先输入一个代表数据集的编号的整数。

然后输入一个整数 $M$，代表数据集中包含数据的个数，$M$ 一定为奇数，数据之间用空格隔开。

数据集的剩余行由数据集的数据构成，每行包含 $10$ 个数据，最后一行数据量可能少于 $10$ 个，数据之间用空格隔开。

**输出格式**

对于每个数据集，第一行输出两个整数，分别代表数据集的编号以及输出中位数的个数（应为数据个数加一的二分之一），数据之间用空格隔开。

数据集的剩余行由输出的中位数构成，每行包含 $10$ 个数据，最后一行数据量可能少于 $10$ 个，数据之间用空格隔开。

输出中不应该存在空行。

**数据范围**

$1≤P≤1000$, $1≤M≤99999$, 所有 $M$ 相加之和不超过 $5×10^5$。

**输入样例**：

```
3 
1 9 
1 2 3 4 5 6 7 8 9 
2 9 
9 8 7 6 5 4 3 2 1 
3 23 
23 41 13 22 -3 24 -31 -11 -8 -7 
3 5 103 211 -311 -45 -67 -73 -81 -99 
-33 24 56
```

**输出样例**：

```
1 5
1 2 3 4 5
2 5
9 8 7 6 5
3 12
23 23 22 22 13 3 5 5 3 -3 
-7 -3
```

#### 解析

动态中位数的经典做法的就是 **对顶堆**

建立两个堆，一个 **大根堆**，一个 **小根堆**，依次读入整个序列的过程中，设当前序列长度为 $M$，维护：

1. 序列中从小到大排名为 $1 \sim \lfloor M / 2 \rfloor$ 的整数存储在大根堆中
2. 序列中从小到大排名为 $\lfloor M / 2 \rfloor + 1 \sim M$ 的整数存储在小根堆中

任何时候，如果某一个堆中元素个数过多，打破这一性质，就取出该堆堆顶元素放入另一个堆

这样一来，序列的中位数就是小根堆的堆顶元素

每次插入新数值 $X$ 时，若 $X$ 比中位数小，则插入大顶堆；否则插入小顶堆，然后检查并维护上述性质

```cpp
void adjust(priority_queue<int> &up, priority_queue<int, vector<int>, greater<>> &dw)
{
    if (up.size() > dw.size())
    {
        dw.push(up.top());
        up.pop();
    }
    else if (dw.size() > up.size() + 1)
    {
        up.push(dw.top());
        dw.pop();
    }
}
void solve()
{
    priority_queue<int> up;
    priority_queue<int, vector<int>, greater<int>> dw;
    int cnt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        cin >> t;
        if (up.size() && up.top() > t) up.push(t);
        else dw.push(t);
        
        adjust(up, dw);
        
        if (i & 1)
        {
            cout << dw.top() << " ";
            if ( ++ cnt % 10 == 0) cout << endl;
        }
    }
    if (cnt % 10) cout << endl;
}
```

### 超快速排序

#### 题目描述

在这个问题中，您必须分析特定的排序算法----超快速排序。

该算法通过交换两个相邻的序列元素来处理 $n$ 个不同整数的序列，直到序列按升序排序。

对于输入序列 `9 1 0 5 4`，超快速排序生成输出 `0 1 4 5 9`。

您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。

**输入格式**

输入包括一些测试用例。

每个测试用例的第一行输入整数 $n$，代表该用例中输入序列的长度。

接下来 $n$ 行每行输入一个整数 $a_i$ 代表用例中输入序列的具体数据，第 $i$ 行的数据代表序列中第 $i$ 个数。

当输入用例中包含的输入序列长度为 $0$ 时，输入终止，该序列无需处理。

**输出格式**

对于每个需要处理的输入序列，输出一个整数 `op`，代表对给定输入序列进行排序所需的最小交换操作数，每个整数占一行。

**数据范围**

$0≤n<500000$, 一个测试点中，所有 n 的和不超过 $500000$。

$0≤ai≤999999999$

**输入样例**：

```
5
9
1
0
5
4
3
1
2
3
0
```

**输出样例**：

```
6
0
```

#### 解析

只通过比较和交换相邻两个数值的排序方法，实际上就是冒泡排序

排序过程中，每找到大小颠倒的相邻数值，就把他们交换

每次交换就会使整个序列的逆序对个数减少 1 且排好序后，逆序对个数为 0

于是能得出人尽皆知的结论：序列冒泡排序过程中的交换操作的次数 = 序列中逆序对个数

本题就等价于求逆序对个数，套模板即可

```cpp
long long cal_revpair(int l, int r)
{
    if (l == r) return 0;
    
    int mid = (l + r) >> 1;
    long long cnt = cal_revpair(l, mid) + cal_revpair(mid + 1, r);
    
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r)
    {
        if (a[i] > a[j]) cnt += mid - i + 1, b[k ++ ] = a[j ++ ];
        else b[k ++ ] = a[i ++ ];
    }
    while (i <= mid) b[k ++ ] = a[i ++ ];
    while (j <= r) b[k ++ ] = a[j ++ ];
    
    for (int i = 0; i < k; i ++ ) a[l + i] = b[i];
    return cnt;
}
```

### 奇数码问题

#### 题目描述

你一定玩过八数码游戏，它实际上是在一个 $3×3$ 的网格中进行的，$1$ 个空格和 $1∼8$ 这 $8$ 个数字恰好不重不漏地分布在这 $3×3$ 的网格中。

例如：

```
5 2 8
1 3 _
4 6 7
```

在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。

例如在上例中，空格可与左、上、下面的数字交换，分别变成：

```
5 2 8       5 2 _      5 2 8
1 _ 3       1 3 8      1 3 7
4 6 7       4 6 7      4 6 _
```

奇数码游戏是它的一个扩展，在一个 $n×n$ 的网格中进行，其中 $n$ 为奇数，$1$ 个空格和 $1∼n^2−1$ 这 $n^2−1$ 个数恰好不重不漏地分布在 $n×n$ 的网格中。

空格移动的规则与八数码游戏相同，实际上，八数码就是一个 $n=3$ 的奇数码游戏。

现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。

**输入格式**

多组数据，对于每组数据：

第 $1$ 行输入一个整数 $n$，$n$ 为奇数。

接下来 $n$ 行每行 $n$ 个整数，表示第一个局面。

再接下来 $n$ 行每行 $n$ 个整数，表示第二个局面。

局面中每个整数都是 $0∼n^2−1$ 之一，其中用 $0$ 代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。

**输出格式**

对于每组数据，若两个局面可达，输出 `TAK`，否则输出 `NIE`。

**数据范围**

$1≤n<500$

**输入样例**：
```
3
1 2 3
0 4 6
7 5 8
1 2 3
4 5 6
7 8 0
1
0
0
```

**输出样例**：

```
TAK
TAK
```

#### 解析

$n \times m$ 数码问题的优解性判定，可以转化为归并排序求逆序对来解决

**奇数码游戏两个局面可达，当且仅当两个局面下网格中的数依次写成 $1$ 行 $n^2 - 1$ 个元素序列后，逆序对个数的奇偶性相同**

**充分性简单证明：奇数码游戏两个局面可达，则它们对应序列的逆序对奇偶性相等**

1. 空格 **左右移动** 时，序列中逆序对个数显然不变
2. 空格 **上下移动** 时，不妨设区间 $(a_{i,j}, a_{i+1,j})$ 内与 $a_{i,j}$ 构成逆序对的元素个数为 $k$
   则交换后，减少的逆序对个数为 $k$，增加的逆序对个数为 $n - 1 - k$
   则该边的逆序对个数为 $|n - 1 - 2k|$，由于 $n$ 为奇数，故该值为偶数

必要性证明较为复杂，是一个拓扑学问题，找了一圈，没有一个人解释的明白，自己能力也不够，故略

综上，奇数码的任意操作，都不会改变奇数码元素序列的逆序对个数

因此，如果初始奇数码序列逆序对为偶数，则无论怎么操作，都不能变成奇数对逆序对

> **偶数码游戏两个局面可达，当且仅当两个网格写成序列后，“逆序对数之差” 和 “两个局面下空格所在的行数之差” 奇偶性相同**  
> 事实上，$n \times m$ 数码问题的有解性判定，根据列数奇偶性也可分为上述两个结论之一

```cpp
n *= n;
for (int i = 0, t, d = 0; i < n; i ++ )
{
    cin >> t;
    if (t) a[d ++ ] = t;
}
int s1 = cal_revpair(a, 0, n - 2) & 1;
for (int i = 0, t, d = 0; i < n; i ++ )
{
    cin >> t;
    if (t) a[d ++ ] = t;
}
int s2 = cal_revpair(a, 0, n - 2) & 1;
puts(s1 ^ s2 ? "NIE" : "TAK");
```

# 0x06 倍增


## 倍增基本概念

使用倍增算法，要求递推的问题的状态空间关于 2 的次幂具有可划分性

在进行递推时，如果状态空间很大，通常的线性递推无法满足时间和空间的要求

那么我们可以通过倍增的方式，只递推状态空间中在 2 的整数次幂位置上的值作为代表

当需要其他位置上的值时，我们通过 “任意整数可以表示成若干个 2 的次幂项的和” 这一性质，使用之前求出的代表值拼成所需的值

“倍增” 与 “二进制划分” 两个思想相互结合，降低了求解很多问题的空间与时间复杂度（例如：快速幂）

本节会讲解的内容：序列上的倍增问题，求解RMQ问题的ST表算法

> 后续树的章节还会介绍树上倍增求LCA

## 序列上的倍增问题

试想这样一个问题：

给定一个长度为 $N$ 的序列 $A$，然后进行若干次询问，每次给定一个整数 $T$，求出最大的 $k$，满足 $\sum_{i=1}^kA_i \le T$。

算法要求强制在线，且 $0 \le T \le \sum_{i=1}^n A_i$

最朴素的做法是从前往后枚举 $k$，每次询问花费的时间与答案的大小有关，最坏时间复杂度为 $O(N)$

通过简单观察发现，答案具有单调性，因此处理单次询问可以 “二分答案转化为判定”

又观察到每次判定，要用到前缀区间的元素和，因此想到再预处理出一个前缀和优化判定

这样做，处理单词询问的时间复杂度为：$O(\log N)$

二分的解法在平均意义下表现很好，但是缺点在于如果每次询问给定的整数 $T$ 非常小，导致答案 $k$ 也很小，那么该算法可能还不如从前往后枚举更优

于是可以设计出这样一种倍增算法：

1. 令 $p = 1$, $k = 0$, $sum = 0$，其中 $p$ 为 2 次幂跨度，$k$ 为当前前缀下标，$sum$ 为当前前缀和
2. 比较 “$A$ 数组中 $k$ 之后的 $p$ 个数的和” 与 “$T$” 的关系
   1. 如果 $sum + S_{k + p} - S_{k} \le T$，则令 `sum += s[k + p] - s[k], k += p, p *= 2`  
   即累加上这一段，并让 $p$ 的跨度增长一倍
   1. 如果 $sum + S_{k + p} - S_{k} \gt T$，则令 `p /= 2`
3. 重复上一步，直到 $p$ 的值变为 $0$，此时 $k$ 即为答案

```cpp
int p = 1, k = 0, sum = 0;
while (p)
{
    if (sum + s[k + p] - s[k] <= T)
    {
        sum += s[k + p] - s[k];
        k += p;
        p *= 2;
    }
    else p /= 2;
}
```

&emsp;&emsp;这个算法始终在答案大小的范围内实施 “倍增” 与 “二进制划分” 思想，通过若干长度为 $2$ 的次幂的区间拼成最后的 $k$，时间复杂度为 $O(\log k)$，能够应对 $T$ 的各种大小情况。

&emsp;&emsp;而且序列上倍增还有一个规律，就是一开始 $p$ 连续成倍增长，之后 $p$ 连续折半递减。

## ST算法

> RMQ的经典应用就是ST表算法，很多人可能只知道RMQ，却不知道其就是倍增的一种产物

给定一个长度为 $N$ 的序列 $A$，ST算法能在 $O(N\log N)$ 时间的预处理后，以 $O(1)$ 的时间在线处理 “序列 $A$ 的下标在 $[l,r]$ 之间的数的最值是多少” 这样的区间最值询问

一个序列的子区间个数为 $N^2$ 个，根据倍增的思想，首先在这 $N^2$ 个状态空间里选择一些 $2$ 的整数次幂的位置作为代表值

设 $f[i, j]$ 表示序列 $A$ 的子区间 $[i, i + 2^j - 1]$ 里的最值

即从 $i$ 开始(包括 $i$) 的 $2^j$ 个数的最大值

问题的边界显然是 $F[i,0] = A_i$，递推式为：$F[i,j] = \max{F[i, j - 1], F[i + 2^{j-1}, j - 1]}$

即区间 $[i, i + 2^j - 1]$ 的最大值为区间 $[i, i + 2^{i-1}-1]$ 与区间 $[i + 2^{j-1}, i + 2^j - 1]$ 的最大值

再考虑一下 $j$ 的范围：极限情况下是求区间 $[1, n]$ 的最值，于是有 $1 + 2^j - 1 \le n$

化简易得：$2^j \le n \quad\Rightarrow\quad \log_{2}^{2^j} \le \log_{2}^{n} \quad\Rightarrow\quad j \le \log_2^n \quad\Rightarrow\quad j \le \lceil \log_2^n \rceil$

```cpp
void ST_prework()
{
    for (int i = 1; i <= n; i ++ ) f[i][0] = a[i];
    int t = log(n) / log(2) + 1;
    for (int j = 1; j < t; j ++ )
        for (int i = 1; i <= n - (1 << j) + 1; i ++ )
            f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
}
```

当询问区间 $[l,r]$ 时，先计算出 $k$，满足 $2^k < r - l + 1 \le 2^{k+1}$，即小于区间长的最大 $2$ 的 $k$ 次幂

这样保证两个子区间：$[l, l + 2^k - 1]$ 和 $[r - 2^k + 1, r]$ 一定能覆盖住区间 $[l, r]$

两个区间的最大值的最大值，即为整个区间的最大值

```cpp
int ST_query(int l, int r)
{
    int k = log(r - l + 1) / log(2);
    return max(f[l][k], f[r - (1 << k) + 1][k]);
}
```

> `log` 函数为 `cmath` 库里的函数，因为其效率很高，因此我们近似看成 $O(1)$ 无碍

## 习题

### 天才ACM

#### 题目描述

给定一个整数 $M$，对于任意一个整数集合 $S$，定义“**校验值**”如下:

从集合 $S$ 中取出 $M$ 对数(即 $2×M$ 个数，不能重复使用集合中的数，如果 $S$ 中的整数不够 $M$ 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 $S$ 的“校验值”。

现在给定一个长度为 $N$ 的数列 $A$ 以及一个整数 $T$

我们要把 $A$ 分成若干段，使得每一段的“**校验值**”都不超过 $T$

求最少需要分成几段

**输入格式**

第一行输入整数 $K$，代表有 $K$ 组测试数据

对于每组测试数据，第一行包含三个整数 $N$, $M$, $T$

第二行包含 $N$ 个整数，表示数列 $A_1, A_2, …, A_N$

**输出格式**

对于每组测试数据，输出其答案，每个答案占一行

**数据范围**

$1≤K≤12$, $1≤N,M≤500000$, $0≤T≤10^{18}$, $0≤A_i≤2^{20}$

**输入样例**：

```
2
5 1 49
8 2 1 7 9
5 1 64
8 2 1 7 9
```

**输出样例**：

```
2
1
```

#### 解析

**先考虑如何求一个集合的校验值？**

结论：选出 $m$ 个最大值和 $m$ 个最小值，然后最大值配对最小值，次大值配对次小值 ......

证明：假设排序后的 $2m$ 个数为 $a_1, a_2, \cdots, a_{2m}$

按照上述策略配对，有：$|a_{2m}-a_1|^2 + |a_{2m-1}-a_2|^2 + \cdots + |a_{m+1}-a_{m}|^2$

考虑交换配对 $(a, b)$ 和 $(c, d)$，其中 $i < j$

故有大小关系：$a < c < d < b$，校验值为：$(d-c)^2 + (b - a)^2$

交换配对后，有两种情况，第一种情况为：$(a, c)$ 和 $(d, b)$

其校验值为：$(c-a)^2 + (b - d)^2$，两个等式作差易得：

$$
\frac{1}{2}(v_1 - v_2) = ac + bd - cd - ab = b(d-a) - c(d-a) = (b-c)(d-a) \ge 0
$$

交换之后，显然方案不会变差，第二种情况为：$(a, d)$ 和 $(c, b)$

其校验值为：$(d-a)^2 + (b-c)^2$，两个等式作差易得：

$$
\frac{1}{2}(v_1-v_3) = ad+bc-cd-ab = -d(c-a) + b(c-a) = (c-a)(b-d) \ge 0
$$

交换之后，显然方案不会变差

$\mathbf{QED}$

**考虑如何分段？**

由于题设要求是分成的段数尽可能少，因此每段要求尽可能长，这就与“序列前缀区间和询问”一样了

不过那一题是求前缀区间和不少于 $T$，这一题是前缀校验值不少于 $T$

这题就会体现出 “倍增” 和 “二分” 的区别了

由于每次要判定当前的答案是否满足条件，因此每次判定，都要对答案区间进行排序，然后配对

“倍增” 和 “二分” 找答案的时间复杂度基本一致，差的只是常数，但问题主要出现在答案判定上

如果用二分，每一次二分的中点就是 $mid = \frac{l + n}{2}$，这个 $mid$ 与 $n$ 是一个数量级的

因此如果答案的每个段很小，那么每次排序复杂度为 $O(n\log n)$，总复杂度是 $O(n^2\log n)$

如果用 “倍增” 寻找答案，他会从小区间往大区间扩展，效率高于二分，这里可以给出数学证明：

假设倍增到答案过程中判定的区间长度分别为：$l_1, l_2, \cdots, l_k$，先考虑单次分段倍增的复杂度：

$$
O\Big(\sum _{i=1}^k l_i\log l_i) \le O(\log n \times \sum_{i=1}^k l_i\Big) \le O(\log n \times \sum_{i=1}^k l_k)
\le O(\log n \times \log n l_k) = O(l_k \log^2 n)
$$

将所有的段加起来，总的时间复杂度为：$O(n \log^2 n)$ 远远优于二分做法

倍增过程如下：

1. 初始化 $p = 1$, $R = L$
2. 求出 $[L, R + p]$ 这一段区间的校验值：
   1. 若校验值 $\le T$，则 `R += p, p *= 2`
   2. 若校验值 $\gt T$，则 `p /= 2`
3. 重复上一步，直到 $p$ 变为 $0$ 为止，此时 $R$ 即为所求

```cpp
bool check(int l, int r)
{
    int k = 0;
    for (int i = l; i < r; i ++ ) b[k ++ ] = a[i];
    sort(b, b + k);
    LL sum = 0;
    for (int i = 0; i < m && i < k; i ++ , k -- )
        sum += (LL) (b[i] - b[k - 1]) * (b[i] - b[k - 1]);
    return sum <= T;
}
void solve()
{
    scanf("%d%d%lld", &n, &m, &T);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    int l = 0, cnt = 0;
    while (l < n)
    {
        int p = 1, r = l;
        while (p)
        {
            if (r + p <= n && check(l, r + p))
            {
                r += p;
                p *= 2;
            }
            else p /= 2;
        }
        cnt ++ ;
        l = r;
    }
    printf("%d\n", cnt);
}
```

#### 二路归并优化

不难发现，在倍增的过程中，排序的片段中前缀数组已经有序（因为上一轮倍增好后排好了）

即 $[l, r)$ 已经有序，现在倍增需要检验的区间为 $[l, r + p)$

如上面的做法，采用直接对 $[l, r + p)$ 区间排序的策略，最终的时间复杂度为 $O(n\log^2n)$

既然前缀区间已有序，不妨只排 $[r, r + p)$，再将两个区间做一次 **二路归并**，单次分段的时间复杂度如下：

$$
O\Big(\sum_{i=1}^k [(l_i - l_{i-1}) \log (l_i - l_{i-1}) + l_i]\Big) = 
O\Big(\sum_{i=1}^k [(l_i - l_{i-1}) \log (l_i - l_{i-1})]\Big) = 
O\Big(l_k \log l_k\Big)
$$

这样总的时间复杂度为：$O(n\log n)$，是本题的最优解

```cpp
bool check(int l, int mid, int r)
{
    for (int i = mid; i < r; i ++ ) b[i] = a[i];
    sort(b + mid, b + r);
    int i = l, j = mid, k = 0;
    while (i < mid && j < r)
    {
        if (b[i] < b[j]) t[k ++ ] = b[i ++ ];
        else t[k ++ ] = b[j ++ ];
    }
    while (i < mid) t[k ++ ] = b[i ++ ];
    while (j < r) t[k ++ ] = b[j ++ ];
    
    LL sum = 0;
    for (int i = 0; i < m && i < k; i ++ , k -- )
        sum += (LL) (t[i] - t[k - 1]) * (t[i] - t[k - 1]);
    return sum <= T;
}
void solve()
{
    scanf("%d%d%lld", &n, &m, &T);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    int l = 0, cnt = 0;
    while (l < n)
    {
        int p = 1, r = l;
        while (p)
        {
            if (r + p <= n && check(l, r, r + p))
            {
                r += p;
                p *= 2;
                for (int i = l; i < r; i ++ )
                    b[i] = t[i - l];
            }
            else p /= 2;
        }
        cnt ++ ;
        l = r;
    }
    printf("%d\n", cnt);
}
```

# 0x07 贪心


## 贪心算法基础概念

> From Wikipedia  
> A greedy algorithm is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage. In many problems, a greedy strategy does not produce an optimal solution, but a greedy heuristic can yield locally optimal solutions that approximate a globally optimal solution in a reasonable amount of time.

贪心类问题无疑是基础算法中难度最大的，难点在于思维的跳跃性，没有固定的解题模式，往往是一类题一种解法或结论

**贪心算法(Greedy Algorithm)** 这样的称呼，往往让刚学习的朋友会误解这类题目的特性

**Greedy Algorithm** 实际上是在每个阶段做出 **启发式（heuristic）** 的 **局部最优化选择**，从而达到 **全局最优化** 的行为

> **heuristic** 在数学最优化问题中的定义：a technique designed for solving a problem more quickly when classic methods are too slow or for finding an approximate solution when classic methods fail to find any exact solution  即在常规方法不能有效求解时，需要用到的启发式求解（这也就是为什么贪心问题特别杂，往往一题一结论，很难掌握）

如果用“状态空间”来理解的话，**动态规划(Dynamic Programming)** 在每个 **stage** 求解所有需要的状态实现递推

而 **贪心算法(Greedy Algorithm)** 则是在每个 **stage** 根据 **启发式策略** 策略只去求解部分解实现递推

从“集合”来理解的话，DP就是把每个状态集合都求干净进行递推；贪心则是每次求集合中的符合策略的一部分递推

## 贪心类型题目解法

之前也说过，贪心类题目没有固定解题模式，不像数据结构计算几何可以一步步推理得出，贪心解法具有跳跃性

使用贪心算法要求问题的整体最优性可以由局部最优性导出

因此，我们可以从局部最优策略下手，证明该策略也可以实现整体最优

常见的证明手段：

1. 微扰（邻项交换）
   证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果变差  
   常用于以 “排序” 为贪心策略的证明（减少逆序对不会使整体结果变差）  
2. 范围缩放
   证明任何对局部最优策略作用范围的扩展都不会造成整体结果变差
3. 决策包容性
   证明任意局面下，做出局部最优决策以后，在问题状态空间中的可达集合包含了做出其他任何决策后的可达集合  
   换言之，这个局部最优策略提供的可能性包含其他有策略提供的可能性  
4. 反证法
5. 数学归纳法

## 常见的贪心模型

1. 区间问题
   1. 区间选点
      1. 问题：数轴上选尽可能少的点，使得每个区间内至少有一个点
      2. 启发策略：区间按右端点排序，若当前区间包含当前的点，则不加入新点，否则更新新点为右端点
   2. 最大不相交区间数量
      1. 问题：数轴上有若干区间，选出最大不相交区间
      2. 启发策略：与上一个问题等价，右端点排序，若当前区间与正在维护的区间相交，则不选，否则选上当前区间并维护
   3. 区间分组
      1. 问题：数轴上有若干区间，给这些区间分组，使得每组内不相交
      2. 启发策略：区间按左端点排序，若当前所有组中最后一个加入的区间右端点都大于当前区间左端点，则开新组，否则接在最小的后面
   4. 区间覆盖
      1. 问题：选择尽可能少的区间，覆盖一个线段
      2. 启发策略：区间按左端点排序，找出所有左端点在当前已覆盖的区间内，最远的右端点位置，更新已覆盖区间，继续枚举
2. Huffman 树模型
   1. 问题：给出几个带权点，每次可以合并几个点，求最小带权路径长
   2. 启发策略：每次选最小的几个点合并
3. 排序不等式
   1. 问题：小学奥数的排队打水问题
   2. 启发策略：按照时间递增排序
4. 绝对值不等式
   1. 详情见“排序”章节
5. 模拟退火
   1. 问题：找多峰函数的极值
   2. 启发策略：这个内容很多，以后章节会详细讲

## 习题

### 防晒

#### 题目描述

有 $C$ 头奶牛进行日光浴，第 $i$ 头奶牛需要 $minSPF[i]$ 到 $maxSPF[i]$ 单位强度之间的阳光。

每头奶牛在日光浴前必须涂防晒霜，防晒霜有 $L$ 种，涂上第 $i$ 种之后，身体接收到的阳光强度就会稳定为 $SPF[i]$，第 $i$ 种防晒霜有 $cover[i]$ 瓶。

求最多可以满足多少头奶牛进行日光浴。

**输入格式**

第一行输入整数 $C$ 和 $L$

接下来的 $C$ 行，按次序每行输入一头牛的 $minSPF$ 和 $maxSPF$ 值，即第 $i$ 行输入 $minSPF[i]$ 和 $maxSPF[i]$

再接下来的 $L$ 行，按次序每行输入一种防晒霜的 $SPF$ 和 $cover$ 值，即第 $i$ 行输入 $SPF[i]$ 和 $cover[i]$

每行的数据之间用空格隔开

**输出格式**

输出一个整数，代表最多可以满足奶牛日光浴的奶牛数目。

**数据范围**

$1≤C,L≤2500$, $1≤minSPF≤maxSPF≤1000$, $1≤SPF≤1000$

**输入样例**：

```
3 2
3 10
2 5
1 5
6 2
4 1
```

**输出样例**：

```
2
```

#### 解析

启发式策略：按照 $maxSPF$ 右端点从小到大排序，然后枚举每头牛，每次选择区间内最小的防晒霜

证明方法有两种，蓝书上的范围缩放和y总的二分图反证不存在增广路径

我简略介绍一下两种证明方法，具体大家可以去参考这两位佬的详细证明过程

**范围缩放**

每瓶防晒霜是否可用，取决于 $[minSPF[i], maxSPF[i]]$

由于牛牛们按照 $maxSPF$ 从小到大排好序了，因此每一个不高于当前奶牛 $maxSPF$ 的防晒霜，都不会高于后续奶牛的 $maxSPF$

对于当前奶牛可用的任意两瓶防晒霜 $x$ 和 $y$，如果 $SPF[x] < SPF[y]$

那么后面其他奶牛与该两瓶防晒霜的关系有：

1. 两瓶都能用
2. 两瓶都不能用
3. $x$ 不能用，$y$ 能用

因此，当前奶牛选择较小的 $x$ 对于整体问题的影响显然比选择较大的 $x$ 更好

另外，每头奶牛对答案的贡献至多为 1。即使放弃当前奶牛，留下防晒霜给后面的奶牛，对答案的贡献也不会变大

综上，得证该策略为正确策略

**增广路径**

将所有区间看做二分图的一个顶点集，将所有防晒霜的点看做另一个顶点集

证明对于当前牛选择该防晒霜的策略下，不存在一条增广路径即可

显然，增广路径的匹配是区间、点交替匹配的，以当前防晒霜的点为起点寻找增广路径（终点一定是未匹配的区间的顶点）

1. 如果向后寻找增广路径，显然会使得路径变短，违背了定义

2. 如果向前寻找增广路径，根据我们枚举的顺序，终点一定是已匹配的区间的顶点，违背了定义

因此不存在增广路径，所以该启发式策略一定是最优策略

```cpp
cin >> n >> m;
spfs[1001] = n; //边界处理最大情况
for (int i = 0; i < n; i ++ ) cin >> seg[i].l >> seg[i].r;
for (int i = 0, x, t; i < m; i ++ )
{
    cin >> x >> t;
    spfs[x] += t;
}
sort(seg, seg + n);
int res = 0;
for (int i = 0; i < n; i ++ )
{
    auto spf = spfs.lower_bound(seg[i].l);
    if (spf -> first <= seg[i].r)
    {
        res ++ ;
        if ( -- spf -> second == 0)
        {
            spfs.erase(spf);
        }
    }
}
cout << res << endl;
```

### 畜栏预定

#### 题目描述

有 $N$ 头牛在畜栏中吃草。

每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。

给定 $N$ 头牛和每头牛开始吃草的时间 $A$ 以及结束吃草的时间 $B$，每头牛在 $[A,B]$ 这一时间段内都会一直吃草。

当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。

求需要的最小畜栏数目和每头牛对应的畜栏方案。

**输入格式**

第 $1$ 行：输入一个整数 $N$。

第 $2..N+1$ 行：第 $i+1$ 行输入第 $i$ 头牛的开始吃草时间 $A$ 以及结束吃草时间 $B$，数之间用空格隔开。

**输出格式**

第 $1$ 行：输入一个整数，代表所需最小畜栏数。

第 $2..N+1$ 行：第 $i+1$ 行输入第 $i$ 头牛被安排到的畜栏编号，编号是从 $1$ 开始的 连续 整数，只要方案合法即可。

**数据范围**

$1≤N≤50000$, $1≤A,B≤1000000$

**输入样例**：

```
5
1 10
2 4
3 6
5 8
4 7
```

**输出样例**：

```
4
1
2
3
2
4
```

#### 解析

**区间分组** 的板子

启发式策略

1. 区间按左端点升序枚举
2. 如果之前 **存在** 一个组的区间右端点不与当前区间左端点相交，则将当前区间插入该组
3. 如果之前 **不存在** 一个组的区间右端点不与当前区间左端点相交，则开一个新的分组存放当前区间

反证法，假设最优解的区间组数是 $m$

考虑在上述做法中，设第一次新建第 $m+1$ 个组的时刻，是在处理第 $i$ 个区间

由于所有区间是按左端点升序排序，所以现在前 $m$ 个组中最后一个区间的左端点一定小于等于第 $i$ 个区间的左端点

且前 $m$ 个组中最小的右端点大于等于第 $i$ 个区间的左端点，所以前 $m$ 个组里最后一个区间一定都包含第 $i$ 个区间的左端点，所以我们就找到了 $m+1$ 个区间存在交集，所以至少需要 $m+1$ 个畜栏，矛盾。

**做法**：用一个小根堆来维护所有组的右端点，以此来判断是否存在一个组的区间右端点不与当前区间左端点相交

```cpp
sort(seg + 1, seg + n + 1);
priority_queue<PII, vector<PII>, greater<PII>> heap;
for (int i = 1; i <= n; i ++ )
{
    if (heap.empty() || heap.top().x >= seg[i].l)
    {
        res[seg[i].id] = heap.size() + 1;
        heap.push({seg[i].r, heap.size() + 1});
    }
    else
    {
        int t = heap.top().y;
        heap.pop();
        res[seg[i].id] = t;
        heap.push({seg[i].r, t});
    }
}
```

### 雷达设备

#### 题目描述

假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。

每个小岛都位于海洋一侧的某个点上。

雷达装置均位于海岸线上，且雷达的监测范围为 $d$，当小岛与某雷达的距离不超过 $d$ 时，该小岛可以被雷达覆盖。

我们使用笛卡尔坐标系，定义海岸线为 $x$ 轴，海的一侧在 $x$ 轴上方，陆地一侧在 $x$ 轴下方。

现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。

**输入格式**

第一行输入两个整数 $n$ 和 $d4，分别代表小岛数目和雷达检测范围。

接下来 $n$ 行，每行输入两个整数，分别代表小岛的 $x$，$y$ 轴坐标。

同一行数据之间用空格隔开。

**输出格式**

输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出 `−1`。

**数据范围**

$1≤n≤1000$, $−1000≤x,y≤1000$

**输入样例**：

```
3 2
1 2
-3 1
2 1
```

**输出样例**：

```
2
```

#### 解析

**区间选点** 板子

启发式策略：

1. 区间按右端点升序排序
2. 对于当前未选点的区间，以他的右端点作为我们选择的点
   1. 之后所有左端点小于该点的区间都被该点覆盖
   2. 对于第一个未被该点覆盖的区间，重复上述操作

证明：

按照上述做法，我们选择的点都是某个区间的右端点，而且由于区间按右端点排好序了，所以我们选择的点也是排好序的

只有在当前区间和上一个点所对应的区间是没有交集时，我们才会选择一个新点，所以所有选出的点所对应的区间两两之间没有交集

找到了 $m$ 个两两之间没有交集的区间，因此我们至少需要选 $m$ 个点，得证启发式策略为最优策略

```cpp
int cnt = 0;
sort(seg + 1, seg + n + 1);
double pos = -1e9;
for (int i = 1; i <= n; i ++ )
{
    if (pos + eps < seg[i].l)
    {
        cnt ++ ;
        pos = seg[i].r;
    }
}
```

### 国王游戏

#### 题目描述

恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。

首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。

然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。

排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是:

排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。

注意，国王的位置始终在队伍的最前面。

**输入格式**

第一行包含一个整数 $n$，表示大臣的人数。

第二行包含两个整数 $a$ 和 $b$，之间用一个空格隔开，分别表示国王左手和右手上的整数。

接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。

**输出格式**

输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。

**数据范围**

$1≤n≤1000$, $0<a,b<10000$

**输入样例**：

```
3
1 1
2 3
7 4
4 6
```

**输出样例**：

```
2
```

#### 解析

不难发现，大臣的次序会影响枚举出来的，因此我们需要一种排序的启发式策略进行求解

因此选择 **领项交换** 来找出局部最优策略

考虑交换 $i$ 与 $i+1$ 位大臣的次序，则交换前，两人获得的奖赏为：

$$
val_i = \frac{1}{R_i} \prod_{k=1}^{i-1}L[k] \quad ,val_{i+1} = \frac{1}{R_{i+1}} L_i \prod_{k=1}^{i-1}L[k]
$$

交换后，两人获得的奖赏为：

$$
val_{i+1}' = \frac{1}{R_i} \prod_{k=1}^{i-1}L[k] \quad ,val_i' = \frac{1}{R_{i+1}} L_{i+1} \prod_{k=1}^{i-1}L[k]
$$

交换前，获得奖赏较多的大臣获得的奖赏为：$\prod\limits_{k=1}^{i-1}L[k] \times \max \Big( \dfrac{1}{R_i}, \dfrac{L_i}{R_{i+1}} \Big)$

交换后，获得奖赏较多的大臣获得的奖赏为：$\prod\limits_{k=1}^{i-1}L[k] \times \max \Big( \dfrac{1}{R_{i+1}}, \dfrac{L_{i+1}}{R_{i}} \Big)$

做差比较交换后式子，先通分再提出因式，有：$f = \max(R_{i+1}, R_{i}L_{i}) - \max(R_i, R_{i+1}L_{i+1})$

我们的目的是使任意邻项发生交换时，获得奖赏不会增大，即若 $f$ 小于等于 $0$，则交换前才更优

由于 $R_j, L_j$ 都是正整数，固有：$R_{j}L_{j} \ge R_j$

若 $R_iL_i < R_{i+1}L_{j+1}$，则：

1. $R_{i+1} > R_iL_i$ 时，$f = R_{i+1} - \max(R_i, R_{i+1}L_{i+1}) \le 0$
2. $R_{i+1} < R_iL_i$ 时，$f = R_iL_i -  \max(R_i, R_{i+1}L_{i+1}) \le 0$

显然，交换前方案更小（优）

若 $R_iL_i \ge R_{i+1}L_{j+1}$，则：

1. $f = R_iL_i -\max(R_i, R_{i+1}L_{i+1}) \ge 0 $

显然，交换后方案更小（优）

综上，排序方案为 按$R_iL_i$升序排列

另外本题最坏情况的前缀积为 $(10^3)^{10000} = 10^{30000}$ 需要上高精度

```cpp
sort(seg + 1, seg + n + 1);
vector<int> prefix = {seg[0].l}, res;
for (int i = 1; i <= n; i ++ )
{
    vector<int> t = div(prefix, seg[i].r);
    if (lw(res, t)) res = t;
    prefix = mul(prefix, seg[i].l);
}
for (int i = res.size() - 1; i >= 0; i -- ) cout << res[i];
cout << endl;
```

### 给树染色

#### 题目描述

一颗树有 $n$ 个节点，这些节点被标号为：$1,2,3…n$，每个节点 $i$ 都有一个权值 $A[i]$。

现在要把这棵树的节点全部染色，染色的规则是：

根节点 $R$ 可以随时被染色；对于其他节点，在被染色之前它的父亲节点必须已经染上了色。

每次染色的代价为 $T×A[i]$，其中 $T$ 代表当前是第几次染色。

求把这棵树染色的最小总代价。

**输入格式**

第一行包含两个整数 $n$ 和 $R$，分别代表树的节点数以及根节点的序号。

第二行包含 $n$ 个整数，代表所有节点的权值，第 $i$ 个数即为第 $i$ 个节点的权值 $A[i]$。

接下来 $n−1$ 行，每行包含两个整数 $a$ 和 $b$，代表两个节点的序号，两节点满足关系： $a$ 节点是 $b$ 节点的父节点。

除根节点外的其他 $n−1$ 个节点的父节点和它们本身会在这 $n−1$ 行中表示出来。

同一行内的数用空格隔开。

**输出格式**

输出一个整数，代表把这棵树染色的最小总代价。

**数据范围**

$1≤n≤1000$, $1≤A[i]≤1000$

**输入样例**：

```
5 1
1 2 1 2 4
1 2
1 3
2 4
3 5
```

**输出样例**：

```
33
```

#### 解析

如果没有“先选父节点”的限制，每轮可以任意选择一个点染色，那么本题就是一个 **排序不等式** 的结论题

考虑加了这一限制后，如何处理本问题，易发现一个简单性质：

对含有最大权值的结点，对其父节点染色后，下一个染色对象必然是他（排序不等式易证）

既然该结点与他的父节点的染色顺序是相邻的，根据该性质，我们可以将这两个点 **合并** 成一个点，合并后的新结点权值，为两个点权值的平均值

例如有权值 $x,y,z$ 的三个点，其中 $x,y$ 染色是连续进行的，那么有两种染色方案：

1. 先 $z$ 后 $x,y$，其代价为：$z + 2x + 3y$
2. 先 $x,y$ 后 $z$，其代价为：$x + 2y + 3z$

做差易得：$x + y - 2z $，若 $z < \dfrac{x+y}{2}$ 时，$z$ 先于 $x,y$；若 $z > \dfrac{x+y}{2}$ 时，$x,y$ 先于 $z$

因此，$x,y,z$ 三点的染色顺序可以转化为 $\dfrac{x+y}{2}, z$ 两点的染色顺序

将上述简单情况推广到一般情况，假设有两组点 $a_1,\cdots,a_n$ 和 $b_1,\cdots,b_m$ 进行染色：

1. 先 $a_i$ 后 $b_i$，其代价为：$\sum_{i=1}^n ia_i + \sum_{i=1}^m (i+n)b_i$
2. 先 $b_i$ 后 $a_i$，其代价为：$\sum_{i=1}^m ib_i + \sum_{i=1}^n (i+m)a_i$

做差易得：$n\sum_{i=1}^mb_i-m\sum_{i=1}^na_i$，若 $\dfrac{\sum_{i=1}^mb_i}{m} > \dfrac{\sum_{i=1}^na_i}{n}$，则 $b_i$ 先于 $a_i$；反之后于

由此得到一个 “等效权值” 的算法：记录每个点是由多少个点合并而成的，一个点的 “等效权值” 定义为：

$$
\text{该点的等效权值} = \dfrac{\text{该点包含的原始权值总和}}{\text{该点包含的原始点数}}
$$

最终做法是：不断在树中找到 “等效权值” 最大的点 $p$，让其与其父节点 $fa$ 合并，并让 $p$ 染色顺序接在 $fa$ 之后，直到树中只剩下一个点为止，合并完成。根据合并过程中的染色顺序，计算最终的代价

**关于答案统计**

我这里给出一个完全不同的思路，不用像y总那样推导出每次便宜后的总值，思维量会稍微小一点

不难发现 “等效权值” 点所代表的一类点可以看做一个集合，那么不妨用 **带权并查集** 来维护每个等效权值点

1. 点权：在根节点维护这个集合的“**等效权值**”以及**集合的大小**
2. 边权：用边权维护在这个集合中该节点的**次序**

这样最后整个树中只会有一个并查集，因此每个点到根的路径长，就是他在染色过程中的次序

```cpp
int find(int u) //边权并查集
{
    if (p[u] != u)
    {
        int t = find(p[u]);
        d[u] += d[p[u]];
        p[u] = t;
    }
    return p[u];
}
void merge(int a, int b) // 注意顺序，要求是b作为父节点，a归到b下面，和一般并查集不一样
{
    p[a] = b;
    d[a] += siz[b];
    siz[b] += siz[a];
}
int get_maxid()
{
    double maxv = 0;
    int id = -1;
    for (int i = 1; i <= n; i ++ )
    {
        if (i != root && find(i) == i && v[i] > maxv)
        {
            id = i;
            maxv = v[i];
        }
    }
    return id;
}

int main()
{
    //读入和初始化
    cin >> n >> root;
    for (int i = 1; i <= n; i ++ )
        cin >> w[i], v[i] = w[i], d[i] = 0, p[i] = i, siz[i] = 1;
    
    for (int i = 1, a, b; i < n; i ++ )
        cin >> a >> b, fa[b] = a;
    
    for (int i = 1; i < n; i ++ )
    {
        int t = get_maxid(), father = find(fa[t]);
        v[father] = (v[t] * siz[t] + v[father] * siz[father]) / (siz[t] + siz[father]);;
        merge(t, father);
    }
    int res = 0;
    for (int i = 1; i <= n; i ++ )
        res += (d[i] + 1) * w[i];
    cout << res << endl;
    return 0;
}
```